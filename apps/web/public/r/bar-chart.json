{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "bar-chart",
  "type": "registry:component",
  "title": "Bar Chart",
  "description": "A composable bar chart with horizontal/vertical orientations and animations",
  "dependencies": [
    "@visx/gradient",
    "@visx/pattern",
    "@visx/shape",
    "motion"
  ],
  "registryDependencies": [
    "https://ui.bklit.com/r/chart-context.json",
    "https://ui.bklit.com/r/grid.json",
    "https://ui.bklit.com/r/chart-tooltip.json",
    "https://ui.bklit.com/r/utils.json"
  ],
  "files": [
    {
      "path": "src/charts/bar-chart.tsx",
      "content": "\"use client\";\n\nimport { localPoint } from \"@visx/event\";\nimport { ParentSize } from \"@visx/responsive\";\nimport { scaleBand, scaleLinear } from \"@visx/scale\";\nimport {\n  Children,\n  isValidElement,\n  type ReactElement,\n  type ReactNode,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport { cn } from \"../lib/utils\";\nimport type { BarProps } from \"./bar\";\nimport {\n  ChartProvider,\n  type LineConfig,\n  type Margin,\n  type TooltipData,\n} from \"./chart-context\";\n\nexport type BarOrientation = \"vertical\" | \"horizontal\";\n\nexport interface BarChartProps {\n  /** Data array - each item should have an x-axis key and numeric values */\n  data: Record<string, unknown>[];\n  /** Key in data for the categorical axis. Default: \"name\" */\n  xDataKey?: string;\n  /** Chart margins */\n  margin?: Partial<Margin>;\n  /** Animation duration in milliseconds. Default: 1100 */\n  animationDuration?: number;\n  /** Aspect ratio as \"width / height\". Default: \"2 / 1\" */\n  aspectRatio?: string;\n  /** Additional class name for the container */\n  className?: string;\n  /** Gap between bar groups as a fraction of band width (0-1). Default: 0.2 */\n  barGap?: number;\n  /** Fixed bar width in pixels. If not set, bars auto-size to fill the band. */\n  barWidth?: number;\n  /** Bar chart orientation. Default: \"vertical\" */\n  orientation?: BarOrientation;\n  /** Whether to stack bars instead of grouping them. Default: false */\n  stacked?: boolean;\n  /** Gap between stacked bar segments in pixels. Default: 0 */\n  stackGap?: number;\n  /** Child components (Bar, Grid, ChartTooltip, etc.) */\n  children: ReactNode;\n}\n\nconst DEFAULT_MARGIN: Margin = { top: 40, right: 40, bottom: 40, left: 40 };\n\n// Extract bar configs from children synchronously\nfunction extractBarConfigs(children: ReactNode): LineConfig[] {\n  const configs: LineConfig[] = [];\n\n  Children.forEach(children, (child) => {\n    if (!isValidElement(child)) {\n      return;\n    }\n\n    const childType = child.type as {\n      displayName?: string;\n      name?: string;\n    };\n    const componentName =\n      typeof child.type === \"function\"\n        ? childType.displayName || childType.name || \"\"\n        : \"\";\n\n    const props = child.props as BarProps | undefined;\n    const isBarComponent =\n      componentName === \"Bar\" ||\n      (props && typeof props.dataKey === \"string\" && props.dataKey.length > 0);\n\n    if (isBarComponent && props?.dataKey) {\n      // Use stroke for tooltip dot color if provided, otherwise fall back to fill\n      // This allows gradient/pattern fills to have a solid dot color\n      const dotColor =\n        props.stroke || props.fill || \"var(--chart-line-primary)\";\n      configs.push({\n        dataKey: props.dataKey,\n        stroke: dotColor,\n        strokeWidth: 0,\n      });\n    }\n  });\n\n  return configs;\n}\n\n// Check if a component should render after the mouse overlay\nfunction isPostOverlayComponent(child: ReactElement): boolean {\n  const childType = child.type as {\n    displayName?: string;\n    name?: string;\n    __isChartMarkers?: boolean;\n  };\n\n  if (childType.__isChartMarkers) {\n    return true;\n  }\n\n  const componentName =\n    typeof child.type === \"function\"\n      ? childType.displayName || childType.name || \"\"\n      : \"\";\n\n  return componentName === \"ChartMarkers\" || componentName === \"MarkerGroup\";\n}\n\ninterface ChartInnerProps {\n  width: number;\n  height: number;\n  data: Record<string, unknown>[];\n  xDataKey: string;\n  margin: Margin;\n  animationDuration: number;\n  barGap: number;\n  barWidthProp?: number;\n  orientation: BarOrientation;\n  stacked: boolean;\n  stackGap: number;\n  children: ReactNode;\n  containerRef: React.RefObject<HTMLDivElement | null>;\n}\n\nfunction ChartInner({\n  width,\n  height,\n  data,\n  xDataKey,\n  margin,\n  animationDuration,\n  barGap,\n  barWidthProp,\n  orientation,\n  stacked,\n  stackGap,\n  children,\n  containerRef,\n}: ChartInnerProps) {\n  const [tooltipData, setTooltipData] = useState<TooltipData | null>(null);\n  const [isLoaded, setIsLoaded] = useState(false);\n  const [hoveredBarIndex, setHoveredBarIndex] = useState<number | null>(null);\n\n  const isHorizontal = orientation === \"horizontal\";\n\n  // Extract bar configs synchronously from children\n  const lines = useMemo(() => extractBarConfigs(children), [children]);\n\n  const innerWidth = width - margin.left - margin.right;\n  const innerHeight = height - margin.top - margin.bottom;\n\n  // Category accessor function - returns string for categorical scale\n  const categoryAccessor = useCallback(\n    (d: Record<string, unknown>): string => {\n      const value = d[xDataKey];\n      if (value instanceof Date) {\n        return value.toLocaleDateString(\"en-US\", {\n          month: \"short\",\n          day: \"numeric\",\n        });\n      }\n      return String(value ?? \"\");\n    },\n    [xDataKey]\n  );\n\n  // For compatibility with ChartContext, provide a Date-based xAccessor\n  const xAccessorDate = useCallback(\n    (d: Record<string, unknown>): Date => {\n      const value = d[xDataKey];\n      if (value instanceof Date) {\n        return value;\n      }\n      return new Date();\n    },\n    [xDataKey]\n  );\n\n  // Category scale (band) - for the categorical axis\n  const categoryScale = useMemo(() => {\n    const domain = data.map((d) => categoryAccessor(d));\n    const range: [number, number] = isHorizontal\n      ? [0, innerHeight]\n      : [0, innerWidth];\n    return scaleBand<string>({\n      range,\n      domain,\n      padding: barGap,\n    });\n  }, [innerWidth, innerHeight, data, categoryAccessor, barGap, isHorizontal]);\n\n  // Band width for bars - use prop if provided, otherwise use scale's bandwidth\n  const bandWidth = barWidthProp ?? categoryScale.bandwidth();\n\n  // Compute max value considering stacking\n  const maxValue = useMemo(() => {\n    if (stacked) {\n      // For stacked bars, sum all values at each data point\n      let max = 0;\n      for (const d of data) {\n        let sum = 0;\n        for (const line of lines) {\n          const value = d[line.dataKey];\n          if (typeof value === \"number\") {\n            sum += value;\n          }\n        }\n        if (sum > max) {\n          max = sum;\n        }\n      }\n      return max || 100;\n    }\n    // For grouped bars, find max single value\n    let max = 0;\n    for (const line of lines) {\n      for (const d of data) {\n        const value = d[line.dataKey];\n        if (typeof value === \"number\" && value > max) {\n          max = value;\n        }\n      }\n    }\n    return max || 100;\n  }, [data, lines, stacked]);\n\n  // Value scale (linear) - for the value axis\n  const valueScale = useMemo(() => {\n    const range = isHorizontal ? [0, innerWidth] : [innerHeight, 0];\n    return scaleLinear({\n      range,\n      domain: [0, maxValue * 1.1],\n      nice: true,\n    });\n  }, [innerWidth, innerHeight, maxValue, isHorizontal]);\n\n  // Compute stack offsets for stacked bars\n  const stackOffsets = useMemo(() => {\n    if (!stacked) {\n      return undefined;\n    }\n    const offsets = new Map<number, Map<string, number>>();\n    for (let i = 0; i < data.length; i++) {\n      const d = data[i];\n      if (!d) {\n        continue;\n      }\n      const pointOffsets = new Map<string, number>();\n      let cumulative = 0;\n      for (const line of lines) {\n        pointOffsets.set(line.dataKey, cumulative);\n        const value = d[line.dataKey];\n        if (typeof value === \"number\") {\n          cumulative += value;\n        }\n      }\n      offsets.set(i, pointOffsets);\n    }\n    return offsets;\n  }, [data, lines, stacked]);\n\n  // Column width for tooltip indicator\n  const columnWidth = useMemo(() => {\n    if (data.length < 1) {\n      return 0;\n    }\n    return isHorizontal ? innerHeight / data.length : innerWidth / data.length;\n  }, [innerWidth, innerHeight, data.length, isHorizontal]);\n\n  // Pre-compute labels for ticker animation\n  const dateLabels = useMemo(\n    () => data.map((d) => categoryAccessor(d)),\n    [data, categoryAccessor]\n  );\n\n  // Create a fake time scale for compatibility with ChartContext\n  const fakeTimeScale = useMemo(() => {\n    const now = Date.now();\n    const start = now - data.length * 24 * 60 * 60 * 1000;\n    const scale = {\n      ...categoryScale,\n      domain: () => [new Date(start), new Date(now)],\n      range: () => [0, innerWidth] as [number, number],\n      invert: (x: number) => new Date(start + (x / innerWidth) * (now - start)),\n      copy: () => scale,\n    };\n    return scale;\n  }, [categoryScale, innerWidth, data.length]);\n\n  // Animation timing\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setIsLoaded(true);\n    }, animationDuration);\n    return () => clearTimeout(timer);\n  }, [animationDuration]);\n\n  // Mouse move handler\n  const handleMouseMove = useCallback(\n    (event: React.MouseEvent<SVGGElement>) => {\n      const point = localPoint(event);\n      if (!point) {\n        return;\n      }\n\n      const pos = isHorizontal ? point.y - margin.top : point.x - margin.left;\n\n      // Find which band the mouse is over\n      const bandIndex = Math.floor(pos / columnWidth);\n      const clampedIndex = Math.max(0, Math.min(data.length - 1, bandIndex));\n      const d = data[clampedIndex];\n\n      if (!d) {\n        return;\n      }\n\n      // Calculate positions for each bar\n      const yPositions: Record<string, number> = {};\n      const xPositions: Record<string, number> = {};\n      const barPos = categoryScale(categoryAccessor(d)) ?? 0;\n\n      if (isHorizontal) {\n        // Horizontal bars: dots at end of bar (x = value), centered vertically in band\n        const seriesCount = lines.length;\n        const groupGap = seriesCount > 1 ? 4 : 0;\n        const individualBarHeight =\n          seriesCount > 0\n            ? (bandWidth - groupGap * (seriesCount - 1)) / seriesCount\n            : bandWidth;\n\n        if (stacked) {\n          // Stacked horizontal: all bars same y, x at cumulative end\n          let cumulative = 0;\n          for (const line of lines) {\n            const value = d[line.dataKey];\n            if (typeof value === \"number\") {\n              cumulative += value;\n              xPositions[line.dataKey] = valueScale(cumulative) ?? 0;\n              yPositions[line.dataKey] = barPos + bandWidth / 2;\n            }\n          }\n        } else {\n          // Grouped horizontal: each bar at its own y position\n          lines.forEach((line, idx) => {\n            const value = d[line.dataKey];\n            if (typeof value === \"number\") {\n              xPositions[line.dataKey] = valueScale(value) ?? 0;\n              yPositions[line.dataKey] =\n                barPos +\n                idx * (individualBarHeight + groupGap) +\n                individualBarHeight / 2;\n            }\n          });\n        }\n      } else if (stacked) {\n        // Vertical stacked bars\n        let cumulative = 0;\n        let seriesIdx = 0;\n        for (const line of lines) {\n          const value = d[line.dataKey];\n          if (typeof value === \"number\") {\n            cumulative += value;\n            const gapOffset = seriesIdx * stackGap;\n            yPositions[line.dataKey] =\n              (valueScale(cumulative) ?? 0) - gapOffset;\n            seriesIdx++;\n          }\n        }\n      } else {\n        // Vertical grouped bars\n        const seriesCount = lines.length;\n        const groupGap = seriesCount > 1 ? 4 : 0;\n        const individualBarWidth =\n          seriesCount > 0\n            ? (bandWidth - groupGap * (seriesCount - 1)) / seriesCount\n            : bandWidth;\n\n        lines.forEach((line, idx) => {\n          const value = d[line.dataKey];\n          if (typeof value === \"number\") {\n            yPositions[line.dataKey] = valueScale(value) ?? 0;\n            xPositions[line.dataKey] =\n              barPos +\n              idx * (individualBarWidth + groupGap) +\n              individualBarWidth / 2;\n          }\n        });\n      }\n\n      // Tooltip position: for horizontal, position at max bar end; for vertical, center of band\n      let tooltipX: number;\n      if (isHorizontal) {\n        // Position tooltip at the end of the longest bar\n        const maxX = Math.max(...Object.values(xPositions), 0);\n        tooltipX = maxX;\n      } else {\n        tooltipX = barPos + bandWidth / 2;\n      }\n\n      setTooltipData({\n        point: d,\n        index: clampedIndex,\n        x: tooltipX,\n        yPositions,\n        xPositions: Object.keys(xPositions).length > 0 ? xPositions : undefined,\n      });\n      setHoveredBarIndex(clampedIndex);\n    },\n    [\n      categoryScale,\n      valueScale,\n      data,\n      lines,\n      margin.left,\n      margin.top,\n      categoryAccessor,\n      columnWidth,\n      bandWidth,\n      isHorizontal,\n      stacked,\n      stackGap,\n    ]\n  );\n\n  const handleMouseLeave = useCallback(() => {\n    setTooltipData(null);\n    setHoveredBarIndex(null);\n  }, []);\n\n  // Early return if dimensions not ready\n  if (width < 10 || height < 10) {\n    return null;\n  }\n\n  const canInteract = isLoaded;\n\n  // Helper to check if a component is a gradient or pattern definition\n  const isDefsComponent = (child: ReactElement): boolean => {\n    const displayName =\n      (child.type as { displayName?: string })?.displayName ||\n      (child.type as { name?: string })?.name ||\n      \"\";\n    return (\n      displayName.includes(\"Gradient\") ||\n      displayName.includes(\"Pattern\") ||\n      displayName === \"LinearGradient\" ||\n      displayName === \"RadialGradient\"\n    );\n  };\n\n  // Separate children into defs, pre-overlay, and post-overlay\n  const defsChildren: ReactElement[] = [];\n  const preOverlayChildren: ReactElement[] = [];\n  const postOverlayChildren: ReactElement[] = [];\n\n  Children.forEach(children, (child) => {\n    if (!isValidElement(child)) {\n      return;\n    }\n\n    if (isDefsComponent(child)) {\n      defsChildren.push(child);\n    } else if (isPostOverlayComponent(child)) {\n      postOverlayChildren.push(child);\n    } else {\n      preOverlayChildren.push(child);\n    }\n  });\n\n  const contextValue = {\n    data,\n    xScale: fakeTimeScale as unknown as ReturnType<\n      typeof import(\"@visx/scale\").scaleTime<number>\n    >,\n    yScale: valueScale,\n    width,\n    height,\n    innerWidth,\n    innerHeight,\n    margin,\n    columnWidth,\n    tooltipData,\n    setTooltipData,\n    containerRef,\n    lines,\n    isLoaded,\n    animationDuration,\n    xAccessor: xAccessorDate,\n    dateLabels,\n    // Bar-specific properties\n    barScale: categoryScale,\n    bandWidth,\n    hoveredBarIndex,\n    setHoveredBarIndex,\n    barXAccessor: categoryAccessor,\n    orientation,\n    stacked,\n    stackOffsets,\n  };\n\n  return (\n    <ChartProvider value={contextValue}>\n      <svg aria-hidden=\"true\" height={height} width={width}>\n        {/* Gradient and pattern definitions */}\n        {defsChildren.length > 0 && <defs>{defsChildren}</defs>}\n\n        <rect fill=\"transparent\" height={height} width={width} x={0} y={0} />\n\n        {/* biome-ignore lint/a11y/noStaticElementInteractions: Chart interaction area */}\n        <g\n          onMouseLeave={canInteract ? handleMouseLeave : undefined}\n          onMouseMove={canInteract ? handleMouseMove : undefined}\n          style={{ cursor: canInteract ? \"crosshair\" : \"default\" }}\n          transform={`translate(${margin.left},${margin.top})`}\n        >\n          {/* Background rect for mouse event detection */}\n          <rect\n            fill=\"transparent\"\n            height={innerHeight}\n            width={innerWidth}\n            x={0}\n            y={0}\n          />\n\n          {/* SVG children rendered before markers */}\n          {preOverlayChildren}\n\n          {/* Markers rendered last so they're on top for interaction */}\n          {postOverlayChildren}\n        </g>\n      </svg>\n    </ChartProvider>\n  );\n}\n\nexport function BarChart({\n  data,\n  xDataKey = \"name\",\n  margin: marginProp,\n  animationDuration = 1100,\n  aspectRatio = \"2 / 1\",\n  className = \"\",\n  barGap = 0.2,\n  barWidth,\n  orientation = \"vertical\",\n  stacked = false,\n  stackGap = 0,\n  children,\n}: BarChartProps) {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const margin = { ...DEFAULT_MARGIN, ...marginProp };\n\n  return (\n    <div\n      className={cn(\"relative w-full\", className)}\n      ref={containerRef}\n      style={{ aspectRatio }}\n    >\n      <ParentSize debounceTime={10}>\n        {({ width, height }) => (\n          <ChartInner\n            animationDuration={animationDuration}\n            barGap={barGap}\n            barWidthProp={barWidth}\n            containerRef={containerRef}\n            data={data}\n            height={height}\n            margin={margin}\n            orientation={orientation}\n            stacked={stacked}\n            stackGap={stackGap}\n            width={width}\n            xDataKey={xDataKey}\n          >\n            {children}\n          </ChartInner>\n        )}\n      </ParentSize>\n    </div>\n  );\n}\n\nBarChart.displayName = \"BarChart\";\n\nexport default BarChart;\n",
      "type": "registry:component",
      "target": "components/charts/bar-chart.tsx"
    },
    {
      "path": "src/charts/bar.tsx",
      "content": "\"use client\";\n\nimport { motion } from \"motion/react\";\nimport { useEffect, useId, useMemo, useState } from \"react\";\nimport { chartCssVars, useChart } from \"./chart-context\";\n\nexport type BarLineCap = \"round\" | \"butt\" | number;\nexport type BarAnimationType = \"grow\" | \"fade\";\n\nexport interface BarProps {\n  /** Key in data to use for y values */\n  dataKey: string;\n  /** Fill color for the bar. Can be a color, gradient url, or pattern url. Default: var(--chart-line-primary) */\n  fill?: string;\n  /** Color for tooltip dot. Use when fill is a gradient/pattern. Default: uses fill value */\n  stroke?: string;\n  /** Line cap style for bar ends: \"round\", \"butt\", or a number for custom radius. Default: \"round\" */\n  lineCap?: BarLineCap;\n  /** Whether to animate the bars. Default: true */\n  animate?: boolean;\n  /** Animation type: \"grow\" (height) or \"fade\" (opacity + blur). Default: \"grow\" */\n  animationType?: BarAnimationType;\n  /** Opacity when not hovered (when another bar is hovered). Default: 0.3 */\n  fadedOpacity?: number;\n  /** Stagger delay between bars in seconds. Auto-calculated if not provided. */\n  staggerDelay?: number;\n  /** Gap between stacked bars in pixels. Default: 0 */\n  stackGap?: number;\n}\n\n// Same easing as Line chart for consistent animation feel\nconst BAR_EASING = \"cubic-bezier(0.85, 0, 0.15, 1)\";\n\ninterface AnimatedBarProps {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  fill: string;\n  rx: number;\n  ry: number;\n  index: number;\n  isFaded: boolean;\n  animationType: BarAnimationType;\n  innerHeight: number;\n  fadedOpacity: number;\n  staggerDelay: number;\n  animationDuration: number;\n  isHorizontal: boolean;\n}\n\nfunction AnimatedBar({\n  x,\n  y,\n  width,\n  height,\n  fill,\n  rx,\n  ry,\n  index,\n  isFaded,\n  animationType,\n  innerHeight,\n  fadedOpacity,\n  staggerDelay,\n  animationDuration,\n  isHorizontal,\n}: AnimatedBarProps) {\n  const [isAnimated, setIsAnimated] = useState(false);\n\n  // Trigger animation after stagger delay\n  useEffect(() => {\n    const timeout = setTimeout(\n      () => {\n        setIsAnimated(true);\n      },\n      index * staggerDelay * 1000\n    );\n    return () => clearTimeout(timeout);\n  }, [index, staggerDelay]);\n\n  // Calculate the duration for this bar's animation\n  // Each bar gets a proportional share of the remaining time\n  const barDuration = animationDuration * 0.6; // 60% of total duration for the animation itself\n\n  // Calculate opacity for fade animation (avoid nested ternary)\n  const getFadeOpacity = () => {\n    if (isFaded) {\n      return fadedOpacity;\n    }\n    return isAnimated ? 1 : 0;\n  };\n\n  if (animationType === \"fade\") {\n    return (\n      <motion.rect\n        animate={{\n          opacity: getFadeOpacity(),\n          filter: isAnimated ? \"blur(0px)\" : \"blur(2px)\",\n        }}\n        fill={fill}\n        height={height}\n        initial={{ opacity: 0, filter: \"blur(2px)\" }}\n        rx={rx}\n        ry={ry}\n        style={{\n          transition: `opacity ${barDuration}ms ${BAR_EASING}, filter ${barDuration}ms ${BAR_EASING}`,\n        }}\n        transition={{\n          opacity: { duration: 0.15 },\n        }}\n        width={width}\n        x={x}\n        y={y}\n      />\n    );\n  }\n\n  // \"grow\" animation - bars grow from origin using CSS transitions\n  const animatedProps = isHorizontal\n    ? {\n        width: isAnimated ? width : 0,\n        height,\n        x: 0,\n        y,\n      }\n    : {\n        width,\n        height: isAnimated ? height : 0,\n        x,\n        y: isAnimated ? y : innerHeight,\n      };\n\n  return (\n    <motion.rect\n      animate={{\n        opacity: isFaded ? fadedOpacity : 1,\n      }}\n      fill={fill}\n      height={animatedProps.height}\n      rx={rx}\n      ry={ry}\n      style={{\n        transition: `width ${barDuration}ms ${BAR_EASING}, height ${barDuration}ms ${BAR_EASING}, x ${barDuration}ms ${BAR_EASING}, y ${barDuration}ms ${BAR_EASING}`,\n      }}\n      transition={{\n        opacity: { duration: 0.15 },\n      }}\n      width={animatedProps.width}\n      x={animatedProps.x}\n      y={animatedProps.y}\n    />\n  );\n}\n\nexport function Bar({\n  dataKey,\n  fill = chartCssVars.linePrimary,\n  lineCap = \"round\",\n  animate = true,\n  animationType = \"grow\",\n  fadedOpacity = 0.3,\n  staggerDelay,\n  stackGap = 0,\n}: BarProps) {\n  const {\n    data,\n    yScale,\n    innerHeight,\n    isLoaded,\n    barScale,\n    bandWidth,\n    hoveredBarIndex,\n    setHoveredBarIndex,\n    barXAccessor,\n    lines,\n    orientation,\n    stacked,\n    stackOffsets,\n    animationDuration,\n  } = useChart();\n\n  // Calculate stagger delay automatically if not provided\n  // Total animation duration is ~1200ms, with 40% for stagger spread and 60% for bar animation\n  const totalAnimDuration = animationDuration || 1100;\n  const staggerSpread = totalAnimDuration * 0.4; // 40% of time for stagger spread\n  const calculatedStaggerDelay =\n    staggerDelay ?? (data.length > 1 ? staggerSpread / 1000 / data.length : 0);\n  const uniqueId = useId();\n\n  const isHorizontal = orientation === \"horizontal\";\n\n  // Find the index of this bar series among all bar series\n  const seriesIndex = useMemo(() => {\n    const idx = lines.findIndex((l) => l.dataKey === dataKey);\n    return idx >= 0 ? idx : 0;\n  }, [lines, dataKey]);\n\n  const seriesCount = lines.length;\n  const isLastSeries = seriesIndex === seriesCount - 1;\n\n  // Calculate the width for each bar within a group (for non-stacked)\n  const barWidth = useMemo(() => {\n    if (!bandWidth || seriesCount === 0) {\n      return 0;\n    }\n    if (stacked) {\n      // Stacked bars use full band width\n      return bandWidth;\n    }\n    // Leave a small gap between grouped bars\n    const groupGap = seriesCount > 1 ? 4 : 0;\n    return (bandWidth - groupGap * (seriesCount - 1)) / seriesCount;\n  }, [bandWidth, seriesCount, stacked]);\n\n  // Calculate corner radius based on lineCap\n  const cornerRadius = useMemo(() => {\n    if (typeof lineCap === \"number\") {\n      return lineCap;\n    }\n    if (lineCap === \"round\" && barWidth) {\n      return Math.min(barWidth / 2, 8);\n    }\n    return 0;\n  }, [lineCap, barWidth]);\n\n  // Early return if bar scale not available (not in BarChart)\n  if (!(barScale && bandWidth && barXAccessor)) {\n    console.warn(\"Bar component must be used within a BarChart\");\n    return null;\n  }\n\n  return (\n    <g className={`bar-series-${uniqueId}`}>\n      {data.map((d, i) => {\n        const value = d[dataKey];\n        if (typeof value !== \"number\") {\n          return null;\n        }\n\n        const categoryValue = barXAccessor(d);\n        const bandPos = barScale(categoryValue) ?? 0;\n\n        let x: number;\n        let y: number;\n        let barHeight: number;\n        let barW: number;\n\n        if (isHorizontal) {\n          // Horizontal bars: category on y-axis, value on x-axis\n          const valuePos = yScale(value) ?? 0;\n          barW = valuePos; // Width is the value position (grows from left)\n          barHeight = barWidth;\n\n          if (stacked && stackOffsets) {\n            const offset = stackOffsets.get(i)?.get(dataKey) ?? 0;\n            x = yScale(offset) ?? 0;\n            barW = valuePos - x;\n            // Apply stack gap for horizontal: shift right and reduce width\n            const gapOffset = seriesIndex * stackGap;\n            x += gapOffset;\n            if (!isLastSeries && stackGap > 0) {\n              barW = Math.max(0, barW - stackGap);\n            }\n          } else {\n            x = 0;\n            // For grouped bars, offset y position\n            const groupGap = seriesCount > 1 ? 4 : 0;\n            y = bandPos + seriesIndex * (barWidth + groupGap);\n          }\n          y = stacked\n            ? bandPos\n            : bandPos + seriesIndex * (barWidth + (seriesCount > 1 ? 4 : 0));\n        } else {\n          // Vertical bars: category on x-axis, value on y-axis\n          const valuePos = yScale(value) ?? 0;\n          barHeight = innerHeight - valuePos;\n          barW = barWidth;\n\n          if (stacked && stackOffsets) {\n            const offset = stackOffsets.get(i)?.get(dataKey) ?? 0;\n            const offsetY = yScale(offset) ?? innerHeight;\n            // Apply stack gap: shift up and reduce height\n            const gapOffset = seriesIndex * stackGap;\n            y = offsetY - barHeight - gapOffset;\n            // Reduce height slightly for non-last bars to create visual gap\n            if (!isLastSeries && stackGap > 0) {\n              barHeight = Math.max(0, barHeight - stackGap);\n            }\n          } else {\n            y = valuePos;\n            // For grouped bars, offset x position\n            const groupGap = seriesCount > 1 ? 4 : 0;\n            x = bandPos + seriesIndex * (barWidth + groupGap);\n          }\n          x = stacked\n            ? bandPos\n            : bandPos + seriesIndex * (barWidth + (seriesCount > 1 ? 4 : 0));\n        }\n\n        const isFaded = hoveredBarIndex !== null && hoveredBarIndex !== i;\n\n        // Use categoryValue as key since it's the unique identifier from data\n        const barKey = `bar-${dataKey}-${categoryValue}`;\n\n        // Apply rounded corners:\n        // - For non-stacked: always apply\n        // - For stacked with gap: apply to all bars\n        // - For stacked without gap: only apply to the last series\n        const applyRounding = !stacked || stackGap > 0 || isLastSeries;\n        const effectiveRx = applyRounding ? cornerRadius : 0;\n        const effectiveRy = applyRounding ? cornerRadius : 0;\n\n        if (animate && !isLoaded) {\n          return (\n            <AnimatedBar\n              animationDuration={totalAnimDuration}\n              animationType={animationType}\n              fadedOpacity={fadedOpacity}\n              fill={fill}\n              height={barHeight}\n              index={i}\n              innerHeight={innerHeight}\n              isFaded={isFaded}\n              isHorizontal={isHorizontal}\n              key={barKey}\n              rx={effectiveRx}\n              ry={effectiveRy}\n              staggerDelay={calculatedStaggerDelay}\n              width={barW}\n              x={x}\n              y={y}\n            />\n          );\n        }\n\n        // Static bar after animation completes\n        return (\n          <motion.rect\n            animate={{\n              opacity: isFaded ? fadedOpacity : 1,\n            }}\n            fill={fill}\n            height={barHeight}\n            key={barKey}\n            onMouseEnter={() => setHoveredBarIndex?.(i)}\n            onMouseLeave={() => setHoveredBarIndex?.(null)}\n            rx={effectiveRx}\n            ry={effectiveRy}\n            style={{\n              cursor: \"pointer\",\n            }}\n            transition={{\n              opacity: { duration: 0.15 },\n            }}\n            width={barW}\n            x={x}\n            y={y}\n          />\n        );\n      })}\n    </g>\n  );\n}\n\nBar.displayName = \"Bar\";\n\nexport default Bar;\n",
      "type": "registry:component",
      "target": "components/charts/bar.tsx"
    },
    {
      "path": "src/charts/bar-x-axis.tsx",
      "content": "\"use client\";\n\nimport { motion } from \"motion/react\";\nimport { useEffect, useMemo, useState } from \"react\";\nimport { cn } from \"../lib/utils\";\nimport { useChart } from \"./chart-context\";\n\nexport interface BarXAxisProps {\n  /** Width of the date ticker box for fade calculation. Default: 50 */\n  tickerHalfWidth?: number;\n  /** Whether to show all labels or skip some for dense data. Default: false */\n  showAllLabels?: boolean;\n  /** Maximum number of labels to show. Default: 12 */\n  maxLabels?: number;\n}\n\ninterface BarXAxisLabelProps {\n  label: string;\n  x: number;\n  crosshairX: number | null;\n  isHovering: boolean;\n  tickerHalfWidth: number;\n}\n\nfunction BarXAxisLabel({\n  label,\n  x,\n  crosshairX,\n  isHovering,\n  tickerHalfWidth,\n}: BarXAxisLabelProps) {\n  const fadeBuffer = 20;\n  const fadeRadius = tickerHalfWidth + fadeBuffer;\n\n  let opacity = 1;\n  if (isHovering && crosshairX !== null) {\n    const distance = Math.abs(x - crosshairX);\n    if (distance < tickerHalfWidth) {\n      opacity = 0;\n    } else if (distance < fadeRadius) {\n      opacity = (distance - tickerHalfWidth) / fadeBuffer;\n    }\n  }\n\n  // Zero-width container approach for perfect centering\n  return (\n    <div\n      className=\"absolute\"\n      style={{\n        left: x,\n        bottom: 12,\n        width: 0,\n        display: \"flex\",\n        justifyContent: \"center\",\n      }}\n    >\n      <motion.span\n        animate={{ opacity }}\n        className={cn(\"whitespace-nowrap text-chart-label text-xs\")}\n        initial={{ opacity: 1 }}\n        transition={{ duration: 0.4, ease: \"easeInOut\" }}\n      >\n        {label}\n      </motion.span>\n    </div>\n  );\n}\n\nexport function BarXAxis({\n  tickerHalfWidth = 50,\n  showAllLabels = false,\n  maxLabels = 12,\n}: BarXAxisProps) {\n  const {\n    margin,\n    tooltipData,\n    containerRef,\n    barScale,\n    bandWidth,\n    barXAccessor,\n    data,\n  } = useChart();\n  const [mounted, setMounted] = useState(false);\n\n  // Only render on client side after mount\n  useEffect(() => {\n    setMounted(true);\n  }, []);\n\n  // Generate labels for each bar\n  const labelsToShow = useMemo(() => {\n    if (!(barScale && bandWidth && barXAccessor)) {\n      return [];\n    }\n\n    const allLabels = data.map((d) => {\n      const label = barXAccessor(d);\n      const bandX = barScale(label) ?? 0;\n      // Center the label under the bar group\n      const x = bandX + bandWidth / 2 + margin.left;\n      return { label, x };\n    });\n\n    // If showAllLabels is true or we have fewer than maxLabels, show all\n    if (showAllLabels || allLabels.length <= maxLabels) {\n      return allLabels;\n    }\n\n    // Otherwise, skip some labels to avoid crowding\n    const step = Math.ceil(allLabels.length / maxLabels);\n    return allLabels.filter((_, i) => i % step === 0);\n  }, [\n    barScale,\n    bandWidth,\n    barXAccessor,\n    data,\n    margin.left,\n    showAllLabels,\n    maxLabels,\n  ]);\n\n  const isHovering = tooltipData !== null;\n  const crosshairX = tooltipData ? tooltipData.x + margin.left : null;\n\n  // Use portal to render into the chart container\n  const container = containerRef.current;\n  if (!(mounted && container)) {\n    return null;\n  }\n\n  // Early return if not in a BarChart\n  if (!barScale) {\n    return null;\n  }\n\n  // Dynamic import to avoid SSR issues\n  const { createPortal } = require(\"react-dom\") as typeof import(\"react-dom\");\n\n  return createPortal(\n    <div className=\"pointer-events-none absolute inset-0\">\n      {labelsToShow.map((item) => (\n        <BarXAxisLabel\n          crosshairX={crosshairX}\n          isHovering={isHovering}\n          key={`${item.label}-${item.x}`}\n          label={item.label}\n          tickerHalfWidth={tickerHalfWidth}\n          x={item.x}\n        />\n      ))}\n    </div>,\n    container\n  );\n}\n\nBarXAxis.displayName = \"BarXAxis\";\n\nexport default BarXAxis;\n",
      "type": "registry:component",
      "target": "components/charts/bar-x-axis.tsx"
    },
    {
      "path": "src/charts/bar-y-axis.tsx",
      "content": "\"use client\";\n\nimport { motion } from \"motion/react\";\nimport { useEffect, useMemo, useState } from \"react\";\nimport { cn } from \"../lib/utils\";\nimport { useChart } from \"./chart-context\";\n\nexport interface BarYAxisProps {\n  /** Whether to show all labels or skip some for dense data. Default: true */\n  showAllLabels?: boolean;\n  /** Maximum number of labels to show. Default: 20 */\n  maxLabels?: number;\n}\n\ninterface BarYAxisLabelProps {\n  label: string;\n  y: number;\n  bandHeight: number;\n  isHovered: boolean;\n}\n\nfunction BarYAxisLabel({\n  label,\n  y,\n  bandHeight,\n  isHovered,\n}: BarYAxisLabelProps) {\n  return (\n    <div\n      className=\"absolute right-0 flex items-center justify-end pr-2\"\n      style={{\n        top: y,\n        height: bandHeight,\n      }}\n    >\n      <motion.span\n        animate={{\n          opacity: isHovered ? 1 : 0.7,\n          color: isHovered\n            ? \"var(--foreground)\"\n            : \"var(--chart-label, var(--color-zinc-500))\",\n        }}\n        className={cn(\"truncate whitespace-nowrap text-right text-xs\")}\n        initial={{\n          opacity: 0.7,\n          color: \"var(--chart-label, var(--color-zinc-500))\",\n        }}\n        style={{ maxWidth: 70 }}\n        transition={{ duration: 0.15 }}\n      >\n        {label}\n      </motion.span>\n    </div>\n  );\n}\n\nexport function BarYAxis({\n  showAllLabels = true,\n  maxLabels = 20,\n}: BarYAxisProps) {\n  const {\n    margin,\n    containerRef,\n    barScale,\n    bandWidth,\n    barXAccessor,\n    data,\n    hoveredBarIndex,\n  } = useChart();\n  const [mounted, setMounted] = useState(false);\n\n  // Only render on client side after mount\n  useEffect(() => {\n    setMounted(true);\n  }, []);\n\n  // Generate labels for each bar\n  const labelsToShow = useMemo(() => {\n    if (!(barScale && bandWidth && barXAccessor)) {\n      return [];\n    }\n\n    const allLabels = data.map((d, i) => {\n      const label = barXAccessor(d);\n      const bandY = barScale(label) ?? 0;\n      // Center the label vertically within the band\n      const y = bandY + margin.top;\n      return { label, y, bandHeight: bandWidth, index: i };\n    });\n\n    // If showAllLabels is true or we have fewer than maxLabels, show all\n    if (showAllLabels || allLabels.length <= maxLabels) {\n      return allLabels;\n    }\n\n    // Otherwise, skip some labels to avoid crowding\n    const step = Math.ceil(allLabels.length / maxLabels);\n    return allLabels.filter((_, i) => i % step === 0);\n  }, [\n    barScale,\n    bandWidth,\n    barXAccessor,\n    data,\n    margin.top,\n    showAllLabels,\n    maxLabels,\n  ]);\n\n  // Use portal to render into the chart container\n  const container = containerRef.current;\n  if (!(mounted && container)) {\n    return null;\n  }\n\n  // Early return if not in a BarChart\n  if (!barScale) {\n    return null;\n  }\n\n  // Dynamic import to avoid SSR issues\n  const { createPortal } = require(\"react-dom\") as typeof import(\"react-dom\");\n\n  return createPortal(\n    <div\n      className=\"pointer-events-none absolute top-0 bottom-0\"\n      style={{\n        left: 0,\n        width: margin.left,\n      }}\n    >\n      {labelsToShow.map((item) => (\n        <BarYAxisLabel\n          bandHeight={item.bandHeight}\n          isHovered={hoveredBarIndex === item.index}\n          key={`${item.label}-${item.y}`}\n          label={item.label}\n          y={item.y}\n        />\n      ))}\n    </div>,\n    container\n  );\n}\n\nBarYAxis.displayName = \"BarYAxis\";\n\nexport default BarYAxis;\n",
      "type": "registry:component",
      "target": "components/charts/bar-y-axis.tsx"
    }
  ]
}