{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "chart-tooltip",
  "type": "registry:component",
  "title": "Chart Tooltip",
  "description": "Composable tooltip components for charts",
  "dependencies": [
    "@number-flow/react",
    "motion"
  ],
  "registryDependencies": [
    "https://ui.bklit.com/r/chart-context.json",
    "https://ui.bklit.com/r/utils.json"
  ],
  "files": [
    {
      "path": "src/charts/tooltip/chart-tooltip.tsx",
      "content": "\"use client\";\n\nimport { motion, useSpring } from \"motion/react\";\nimport { useEffect, useMemo, useState } from \"react\";\nimport { chartCssVars, useChart } from \"../chart-context\";\nimport { DateTicker } from \"./date-ticker\";\nimport { TooltipBox } from \"./tooltip-box\";\nimport { TooltipContent, type TooltipRow } from \"./tooltip-content\";\nimport { TooltipDot } from \"./tooltip-dot\";\nimport { TooltipIndicator } from \"./tooltip-indicator\";\n\n// Spring config for crosshair\nconst crosshairSpringConfig = { stiffness: 300, damping: 30 };\n\nexport interface ChartTooltipProps {\n  /** Whether to show the date pill at bottom. Default: true */\n  showDatePill?: boolean;\n  /** Whether to show the vertical crosshair line. Default: true */\n  showCrosshair?: boolean;\n  /** Whether to show dots on the lines. Default: true */\n  showDots?: boolean;\n  /** Custom content renderer for the tooltip box */\n  content?: (props: {\n    point: Record<string, unknown>;\n    index: number;\n  }) => React.ReactNode;\n  /** Custom row renderer - return array of TooltipRow */\n  rows?: (point: Record<string, unknown>) => TooltipRow[];\n  /** Additional content to show below rows (e.g., markers) */\n  children?: React.ReactNode;\n  /** Custom class name */\n  className?: string;\n}\n\nexport function ChartTooltip({\n  showDatePill = true,\n  showCrosshair = true,\n  showDots = true,\n  content,\n  rows: rowsRenderer,\n  children,\n  className = \"\",\n}: ChartTooltipProps) {\n  const {\n    tooltipData,\n    width,\n    height,\n    innerHeight,\n    margin,\n    columnWidth,\n    lines,\n    xAccessor,\n    dateLabels,\n    containerRef,\n    orientation,\n    barXAccessor,\n  } = useChart();\n\n  const isHorizontal = orientation === \"horizontal\";\n\n  const [mounted, setMounted] = useState(false);\n\n  // Only render portals on client side after mount\n  useEffect(() => {\n    setMounted(true);\n  }, []);\n\n  const visible = tooltipData !== null;\n  const x = tooltipData?.x ?? 0;\n  const xWithMargin = x + margin.left;\n\n  // For horizontal charts, get the y position from the first line's yPosition (center of bar)\n  const firstLineDataKey = lines[0]?.dataKey;\n  const firstLineY = firstLineDataKey\n    ? (tooltipData?.yPositions[firstLineDataKey] ?? 0)\n    : 0;\n  const yWithMargin = firstLineY + margin.top;\n\n  // Animated crosshair position\n  const animatedX = useSpring(xWithMargin, crosshairSpringConfig);\n\n  useEffect(() => {\n    animatedX.set(xWithMargin);\n  }, [xWithMargin, animatedX]);\n\n  // Generate rows from lines\n  const tooltipRows = useMemo(() => {\n    if (!tooltipData) {\n      return [];\n    }\n\n    if (rowsRenderer) {\n      return rowsRenderer(tooltipData.point);\n    }\n\n    // Default: generate rows from registered lines\n    return lines.map((line) => ({\n      color: line.stroke,\n      label: line.dataKey,\n      value: (tooltipData.point[line.dataKey] as number) ?? 0,\n    }));\n  }, [tooltipData, lines, rowsRenderer]);\n\n  // Title from date or category\n  const title = useMemo(() => {\n    if (!tooltipData) {\n      return undefined;\n    }\n    if (isHorizontal && barXAccessor) {\n      // For horizontal bar charts, use the category name\n      return barXAccessor(tooltipData.point);\n    }\n    // For vertical charts, use the date\n    return xAccessor(tooltipData.point).toLocaleDateString(\"en-US\", {\n      weekday: \"short\",\n      month: \"short\",\n      day: \"numeric\",\n    });\n  }, [tooltipData, isHorizontal, barXAccessor, xAccessor]);\n\n  // Use portal to render into the chart container\n  // Only render after mount on client side\n  const container = containerRef.current;\n  if (!(mounted && container)) {\n    return null;\n  }\n\n  // Dynamic import to avoid SSR issues\n  const { createPortal } = require(\"react-dom\") as typeof import(\"react-dom\");\n\n  const tooltipContent = (\n    <>\n      {/* Crosshair indicator - rendered as SVG overlay */}\n      {showCrosshair && (\n        <svg\n          aria-hidden=\"true\"\n          className=\"pointer-events-none absolute inset-0\"\n          height=\"100%\"\n          width=\"100%\"\n        >\n          <g transform={`translate(${margin.left},${margin.top})`}>\n            <TooltipIndicator\n              colorEdge={chartCssVars.crosshair}\n              colorMid={chartCssVars.crosshair}\n              columnWidth={columnWidth}\n              fadeEdges\n              height={innerHeight}\n              visible={visible}\n              width=\"line\"\n              x={x}\n            />\n          </g>\n        </svg>\n      )}\n\n      {/* Dots on bars/lines - show for vertical charts only */}\n      {showDots && visible && !isHorizontal && (\n        <svg\n          aria-hidden=\"true\"\n          className=\"pointer-events-none absolute inset-0\"\n          height=\"100%\"\n          width=\"100%\"\n        >\n          <g transform={`translate(${margin.left},${margin.top})`}>\n            {lines.map((line) => (\n              <TooltipDot\n                color={line.stroke}\n                key={line.dataKey}\n                strokeColor={chartCssVars.background}\n                visible={visible}\n                x={tooltipData?.xPositions?.[line.dataKey] ?? x}\n                y={tooltipData?.yPositions[line.dataKey] ?? 0}\n              />\n            ))}\n          </g>\n        </svg>\n      )}\n\n      {/* Tooltip Box */}\n      <TooltipBox\n        className={className}\n        containerHeight={height}\n        containerRef={containerRef}\n        containerWidth={width}\n        top={isHorizontal ? undefined : margin.top}\n        visible={visible}\n        x={xWithMargin}\n        y={isHorizontal ? yWithMargin : margin.top}\n      >\n        {content ? (\n          content({\n            point: tooltipData?.point ?? {},\n            index: tooltipData?.index ?? 0,\n          })\n        ) : (\n          <TooltipContent rows={tooltipRows} title={title}>\n            {children}\n          </TooltipContent>\n        )}\n      </TooltipBox>\n\n      {/* Date/Category Ticker - only show for vertical charts */}\n      {showDatePill && dateLabels.length > 0 && visible && !isHorizontal && (\n        <motion.div\n          className=\"pointer-events-none absolute z-50\"\n          style={{\n            left: animatedX,\n            transform: \"translateX(-50%)\",\n            bottom: 4,\n          }}\n        >\n          <DateTicker\n            currentIndex={tooltipData?.index ?? 0}\n            labels={dateLabels}\n            visible={visible}\n          />\n        </motion.div>\n      )}\n    </>\n  );\n\n  return createPortal(tooltipContent, container);\n}\n\nChartTooltip.displayName = \"ChartTooltip\";\n\nexport default ChartTooltip;\n",
      "type": "registry:component",
      "target": "components/charts/tooltip/chart-tooltip.tsx"
    },
    {
      "path": "src/charts/tooltip/tooltip-box.tsx",
      "content": "\"use client\";\n\nimport { motion, useSpring } from \"motion/react\";\nimport type { RefObject } from \"react\";\nimport { useEffect, useLayoutEffect, useRef, useState } from \"react\";\nimport { cn } from \"../../lib/utils\";\n\n// Spring config for smooth tooltip movement\nconst springConfig = { stiffness: 100, damping: 20 };\n\nexport interface TooltipBoxProps {\n  /** X position in pixels (relative to container) */\n  x: number;\n  /** Y position in pixels (relative to container) */\n  y: number;\n  /** Whether the tooltip is visible */\n  visible: boolean;\n  /** Container ref for portal rendering */\n  containerRef: RefObject<HTMLDivElement | null>;\n  /** Container width for flip detection */\n  containerWidth: number;\n  /** Container height for bounds clamping */\n  containerHeight: number;\n  /** Offset from the target position */\n  offset?: number;\n  /** Custom class name */\n  className?: string;\n  /** Tooltip content */\n  children: React.ReactNode;\n  /** Override left position (bypasses internal calculation) */\n  left?: number | ReturnType<typeof useSpring>;\n  /** Override top position (bypasses internal calculation) */\n  top?: number | ReturnType<typeof useSpring>;\n  /** Force flip direction (for custom positioning) */\n  flipped?: boolean;\n}\n\nexport function TooltipBox({\n  x,\n  y,\n  visible,\n  containerRef,\n  containerWidth,\n  containerHeight,\n  offset = 16,\n  className = \"\",\n  children,\n  left: leftOverride,\n  top: topOverride,\n  flipped: flippedOverride,\n}: TooltipBoxProps) {\n  const tooltipRef = useRef<HTMLDivElement>(null);\n  const [tooltipWidth, setTooltipWidth] = useState(180);\n  const [tooltipHeight, setTooltipHeight] = useState(80);\n  const [mounted, setMounted] = useState(false);\n\n  // Only render portals on client side after mount\n  useEffect(() => {\n    setMounted(true);\n  }, []);\n\n  // Measure tooltip dimensions\n  useLayoutEffect(() => {\n    if (tooltipRef.current) {\n      const w = tooltipRef.current.offsetWidth;\n      const h = tooltipRef.current.offsetHeight;\n      if (w > 0 && w !== tooltipWidth) {\n        setTooltipWidth(w);\n      }\n      if (h > 0 && h !== tooltipHeight) {\n        setTooltipHeight(h);\n      }\n    }\n  }, [tooltipWidth, tooltipHeight]);\n\n  // Calculate positions with flip detection\n  const shouldFlipX = x + tooltipWidth + offset > containerWidth;\n  const targetX = shouldFlipX ? x - offset - tooltipWidth : x + offset;\n\n  // Vertical positioning with bounds clamping\n  const targetY = Math.max(\n    offset,\n    Math.min(y - tooltipHeight / 2, containerHeight - tooltipHeight - offset)\n  );\n\n  // Track flip state for animation\n  const prevFlipRef = useRef(shouldFlipX);\n  const [flipKey, setFlipKey] = useState(0);\n\n  useEffect(() => {\n    if (prevFlipRef.current !== shouldFlipX) {\n      setFlipKey((k) => k + 1);\n      prevFlipRef.current = shouldFlipX;\n    }\n  }, [shouldFlipX]);\n\n  // Animated positions\n  const animatedLeft = useSpring(targetX, springConfig);\n  const animatedTop = useSpring(targetY, springConfig);\n\n  useEffect(() => {\n    animatedLeft.set(targetX);\n  }, [targetX, animatedLeft]);\n\n  useEffect(() => {\n    animatedTop.set(targetY);\n  }, [targetY, animatedTop]);\n\n  // Use overrides when provided\n  const finalLeft = leftOverride ?? animatedLeft;\n  const finalTop = topOverride ?? animatedTop;\n  const isFlipped = flippedOverride ?? shouldFlipX;\n  const transformOrigin = isFlipped ? \"right top\" : \"left top\";\n\n  // Use portal to render into the container\n  const container = containerRef.current;\n  if (!(mounted && container)) {\n    return null;\n  }\n\n  // Dynamic import to avoid SSR issues\n  const { createPortal } = require(\"react-dom\") as typeof import(\"react-dom\");\n\n  if (!visible) {\n    return null;\n  }\n\n  return createPortal(\n    <motion.div\n      animate={{ opacity: 1 }}\n      className={cn(\"pointer-events-none absolute z-50\", className)}\n      exit={{ opacity: 0 }}\n      initial={{ opacity: 0 }}\n      ref={tooltipRef}\n      style={{ left: finalLeft, top: finalTop }}\n      transition={{ duration: 0.1 }}\n    >\n      <motion.div\n        animate={{ scale: 1, opacity: 1, x: 0 }}\n        className=\"min-w-[140px] overflow-hidden rounded-lg bg-zinc-900/80 text-white shadow-lg backdrop-blur-md dark:bg-zinc-900/60\"\n        initial={{ scale: 0.85, opacity: 0, x: isFlipped ? 20 : -20 }}\n        key={flipKey}\n        style={{ transformOrigin }}\n        transition={{ type: \"spring\", stiffness: 300, damping: 25 }}\n      >\n        {children}\n      </motion.div>\n    </motion.div>,\n    container\n  );\n}\n\nTooltipBox.displayName = \"TooltipBox\";\n\nexport default TooltipBox;\n",
      "type": "registry:component",
      "target": "components/charts/tooltip/tooltip-box.tsx"
    },
    {
      "path": "src/charts/tooltip/tooltip-content.tsx",
      "content": "\"use client\";\n\nimport { AnimatePresence, motion } from \"motion/react\";\nimport { type ReactNode, useEffect, useRef, useState } from \"react\";\nimport useMeasure from \"react-use-measure\";\n\nexport interface TooltipRow {\n  color: string;\n  label: string;\n  value: string | number;\n}\n\nexport interface TooltipContentProps {\n  title?: string;\n  rows: TooltipRow[];\n  /** Optional additional content (e.g., markers) */\n  children?: ReactNode;\n}\n\nexport function TooltipContent({ title, rows, children }: TooltipContentProps) {\n  const [measureRef, bounds] = useMeasure({ debounce: 0, scroll: false });\n  const [committedHeight, setCommittedHeight] = useState<number | null>(null);\n  // Track the children state that we've committed to (not the current one)\n  const committedChildrenStateRef = useRef<boolean | null>(null);\n  const frameRef = useRef<number | null>(null);\n\n  const hasChildren = !!children;\n  const markerKey = hasChildren ? \"has-marker\" : \"no-marker\";\n\n  // Check if we're waiting for a structural change to settle\n  // This is true when children state differs from our last committed state\n  const isWaitingForSettlement =\n    committedChildrenStateRef.current !== null &&\n    committedChildrenStateRef.current !== hasChildren;\n\n  // Commit height changes with a frame delay when structure changes\n  useEffect(() => {\n    if (bounds.height <= 0) {\n      return;\n    }\n\n    // Cancel any pending frame\n    if (frameRef.current) {\n      cancelAnimationFrame(frameRef.current);\n      frameRef.current = null;\n    }\n\n    if (isWaitingForSettlement) {\n      // Structure changed - wait for layout to settle before committing\n      frameRef.current = requestAnimationFrame(() => {\n        frameRef.current = requestAnimationFrame(() => {\n          setCommittedHeight(bounds.height);\n          committedChildrenStateRef.current = hasChildren;\n        });\n      });\n    } else {\n      // No structural change, commit immediately\n      setCommittedHeight(bounds.height);\n      committedChildrenStateRef.current = hasChildren;\n    }\n\n    return () => {\n      if (frameRef.current) {\n        cancelAnimationFrame(frameRef.current);\n      }\n    };\n  }, [bounds.height, hasChildren, isWaitingForSettlement]);\n\n  // Animate if we have a committed height\n  const shouldAnimate = committedHeight !== null;\n\n  return (\n    <motion.div\n      // Only animate if we have a committed height, otherwise use auto\n      animate={\n        committedHeight !== null ? { height: committedHeight } : undefined\n      }\n      className=\"overflow-hidden\"\n      // Skip initial animation\n      initial={false}\n      // Apply spring transition when we have a committed height\n      transition={\n        shouldAnimate\n          ? {\n              type: \"spring\",\n              stiffness: 500,\n              damping: 35,\n              mass: 0.8,\n            }\n          : { duration: 0 }\n      }\n    >\n      <div className=\"px-3 py-2.5\" ref={measureRef}>\n        {title && (\n          <div className=\"mb-2 font-medium text-xs text-zinc-400\">{title}</div>\n        )}\n        <div className=\"space-y-1.5\">\n          {rows.map((row) => (\n            <div\n              className=\"flex items-center justify-between gap-4\"\n              key={`${row.label}-${row.color}`}\n            >\n              <div className=\"flex items-center gap-2\">\n                <span\n                  className=\"h-2.5 w-2.5 shrink-0 rounded-full\"\n                  style={{ backgroundColor: row.color }}\n                />\n                <span className=\"text-sm text-zinc-100 dark:text-zinc-400\">\n                  {row.label}\n                </span>\n              </div>\n              <span className=\"font-medium text-sm text-white tabular-nums dark:text-zinc-800\">\n                {typeof row.value === \"number\"\n                  ? row.value.toLocaleString()\n                  : row.value}\n              </span>\n            </div>\n          ))}\n        </div>\n\n        {/* Animated additional content */}\n        <AnimatePresence mode=\"wait\">\n          {children && (\n            <motion.div\n              animate={{ opacity: 1, filter: \"blur(0px)\" }}\n              className=\"mt-2\"\n              exit={{ opacity: 0, filter: \"blur(4px)\" }}\n              initial={{ opacity: 0, filter: \"blur(4px)\" }}\n              key={markerKey}\n              transition={{ duration: 0.2, ease: \"easeOut\" }}\n            >\n              {children}\n            </motion.div>\n          )}\n        </AnimatePresence>\n      </div>\n    </motion.div>\n  );\n}\n\nTooltipContent.displayName = \"TooltipContent\";\n\nexport default TooltipContent;\n",
      "type": "registry:component",
      "target": "components/charts/tooltip/tooltip-content.tsx"
    },
    {
      "path": "src/charts/tooltip/tooltip-dot.tsx",
      "content": "\"use client\";\n\nimport { motion, useSpring } from \"motion/react\";\nimport { useEffect } from \"react\";\nimport { chartCssVars } from \"../chart-context\";\n\n// Faster spring to stay in sync with indicator\nconst crosshairSpringConfig = { stiffness: 300, damping: 30 };\n\nexport interface TooltipDotProps {\n  x: number;\n  y: number;\n  visible: boolean;\n  color: string;\n  size?: number;\n  strokeColor?: string;\n  strokeWidth?: number;\n}\n\nexport function TooltipDot({\n  x,\n  y,\n  visible,\n  color,\n  size = 5,\n  strokeColor = chartCssVars.background,\n  strokeWidth = 2,\n}: TooltipDotProps) {\n  const animatedX = useSpring(x, crosshairSpringConfig);\n  const animatedY = useSpring(y, crosshairSpringConfig);\n\n  useEffect(() => {\n    animatedX.set(x);\n    animatedY.set(y);\n  }, [x, y, animatedX, animatedY]);\n\n  if (!visible) {\n    return null;\n  }\n\n  return (\n    <motion.circle\n      cx={animatedX}\n      cy={animatedY}\n      fill={color}\n      r={size}\n      stroke={strokeColor}\n      strokeWidth={strokeWidth}\n    />\n  );\n}\n\nTooltipDot.displayName = \"TooltipDot\";\n\nexport default TooltipDot;\n",
      "type": "registry:component",
      "target": "components/charts/tooltip/tooltip-dot.tsx"
    },
    {
      "path": "src/charts/tooltip/tooltip-indicator.tsx",
      "content": "\"use client\";\n\nimport { motion, useSpring } from \"motion/react\";\nimport { useEffect } from \"react\";\nimport { chartCssVars } from \"../chart-context\";\n\n// Faster spring for crosshair - responsive to mouse movement\nconst crosshairSpringConfig = { stiffness: 300, damping: 30 };\n\nexport type IndicatorWidth =\n  | number // Pixel width\n  | \"line\" // 1px line (default)\n  | \"thin\" // 2px\n  | \"medium\" // 4px\n  | \"thick\"; // 8px\n\nexport interface TooltipIndicatorProps {\n  /** X position in pixels (center of the indicator) */\n  x: number;\n  /** Height of the indicator */\n  height: number;\n  /** Whether the indicator is visible */\n  visible: boolean;\n  /**\n   * Width of the indicator - number (pixels) or preset.\n   * Ignored if `span` is provided.\n   */\n  width?: IndicatorWidth;\n  /**\n   * Number of columns/days to span, with current point centered.\n   * Requires `columnWidth` to be set.\n   */\n  span?: number;\n  /** Width of a single column/day in pixels. Required when using `span`. */\n  columnWidth?: number;\n  /** Primary color at edges (10% and 90%) */\n  colorEdge?: string;\n  /** Secondary color at center (50%) */\n  colorMid?: string;\n  /** Whether to fade to transparent at 0% and 100% */\n  fadeEdges?: boolean;\n  /** Unique ID for the gradient */\n  gradientId?: string;\n}\n\nfunction resolveWidth(width: IndicatorWidth): number {\n  if (typeof width === \"number\") {\n    return width;\n  }\n  switch (width) {\n    case \"line\":\n      return 1;\n    case \"thin\":\n      return 2;\n    case \"medium\":\n      return 4;\n    case \"thick\":\n      return 8;\n    default:\n      return 1;\n  }\n}\n\nexport function TooltipIndicator({\n  x,\n  height,\n  visible,\n  width = \"line\",\n  span,\n  columnWidth,\n  colorEdge = chartCssVars.crosshair,\n  colorMid = chartCssVars.crosshair,\n  fadeEdges = true,\n  gradientId = \"tooltip-indicator-gradient\",\n}: TooltipIndicatorProps) {\n  const pixelWidth =\n    span !== undefined && columnWidth !== undefined\n      ? span * columnWidth\n      : resolveWidth(width);\n\n  const animatedX = useSpring(x - pixelWidth / 2, crosshairSpringConfig);\n\n  useEffect(() => {\n    animatedX.set(x - pixelWidth / 2);\n  }, [x, animatedX, pixelWidth]);\n\n  if (!visible) {\n    return null;\n  }\n\n  const edgeOpacity = fadeEdges ? 0 : 1;\n\n  return (\n    <g>\n      <defs>\n        <linearGradient id={gradientId} x1=\"0%\" x2=\"0%\" y1=\"0%\" y2=\"100%\">\n          <stop\n            offset=\"0%\"\n            style={{ stopColor: colorEdge, stopOpacity: edgeOpacity }}\n          />\n          <stop offset=\"10%\" style={{ stopColor: colorEdge, stopOpacity: 1 }} />\n          <stop offset=\"50%\" style={{ stopColor: colorMid, stopOpacity: 1 }} />\n          <stop offset=\"90%\" style={{ stopColor: colorEdge, stopOpacity: 1 }} />\n          <stop\n            offset=\"100%\"\n            style={{ stopColor: colorEdge, stopOpacity: edgeOpacity }}\n          />\n        </linearGradient>\n      </defs>\n      <motion.rect\n        fill={`url(#${gradientId})`}\n        height={height}\n        width={pixelWidth}\n        x={animatedX}\n        y={0}\n      />\n    </g>\n  );\n}\n\nTooltipIndicator.displayName = \"TooltipIndicator\";\n\nexport default TooltipIndicator;\n",
      "type": "registry:component",
      "target": "components/charts/tooltip/tooltip-indicator.tsx"
    },
    {
      "path": "src/charts/tooltip/date-ticker.tsx",
      "content": "\"use client\";\n\nimport { motion, useSpring } from \"motion/react\";\nimport { useEffect, useMemo, useRef } from \"react\";\n\nconst TICKER_ITEM_HEIGHT = 24;\n\nexport interface DateTickerProps {\n  currentIndex: number;\n  labels: string[];\n  visible: boolean;\n}\n\nexport function DateTicker({ currentIndex, labels, visible }: DateTickerProps) {\n  // Parse labels into month and day parts\n  const parsedLabels = useMemo(() => {\n    return labels.map((label) => {\n      const parts = label.split(\" \");\n      const month = parts[0] || \"\";\n      const day = parts[1] || \"\";\n      return { month, day, full: label };\n    });\n  }, [labels]);\n\n  // Get unique months and their indices\n  const monthIndices = useMemo(() => {\n    const uniqueMonths: string[] = [];\n    const indices: number[] = [];\n\n    parsedLabels.forEach((label, index) => {\n      if (uniqueMonths.length === 0 || uniqueMonths.at(-1) !== label.month) {\n        uniqueMonths.push(label.month);\n        indices.push(index);\n      }\n    });\n\n    return { uniqueMonths, indices };\n  }, [parsedLabels]);\n\n  // Find current month index\n  const currentMonthIndex = useMemo(() => {\n    if (currentIndex < 0 || currentIndex >= parsedLabels.length) {\n      return 0;\n    }\n    const currentMonth = parsedLabels[currentIndex]?.month;\n    return monthIndices.uniqueMonths.indexOf(currentMonth || \"\");\n  }, [currentIndex, parsedLabels, monthIndices]);\n\n  // Track previous month index\n  const prevMonthIndexRef = useRef(-1);\n\n  // Animated Y offsets\n  const dayY = useSpring(0, { stiffness: 400, damping: 35 });\n  const monthY = useSpring(0, { stiffness: 400, damping: 35 });\n\n  // Update day scroll position\n  useEffect(() => {\n    dayY.set(-currentIndex * TICKER_ITEM_HEIGHT);\n  }, [currentIndex, dayY]);\n\n  // Update month scroll position only when month changes\n  useEffect(() => {\n    if (currentMonthIndex >= 0) {\n      const isFirstRender = prevMonthIndexRef.current === -1;\n      const monthChanged = prevMonthIndexRef.current !== currentMonthIndex;\n\n      if (isFirstRender || monthChanged) {\n        monthY.set(-currentMonthIndex * TICKER_ITEM_HEIGHT);\n        prevMonthIndexRef.current = currentMonthIndex;\n      }\n    }\n  }, [currentMonthIndex, monthY]);\n\n  if (!visible || labels.length === 0) {\n    return null;\n  }\n\n  return (\n    <motion.div\n      className=\"overflow-hidden rounded-full bg-zinc-900 px-4 py-1 text-white shadow-lg dark:bg-zinc-100 dark:text-zinc-900\"\n      layout\n      transition={{\n        layout: { type: \"spring\", stiffness: 400, damping: 35 },\n      }}\n    >\n      <div className=\"relative h-6 overflow-hidden\">\n        <div className=\"flex items-center justify-center gap-1\">\n          {/* Month stack */}\n          <div className=\"relative h-6 overflow-hidden\">\n            <motion.div className=\"flex flex-col\" style={{ y: monthY }}>\n              {monthIndices.uniqueMonths.map((month) => (\n                <div\n                  className=\"flex h-6 shrink-0 items-center justify-center\"\n                  key={month}\n                >\n                  <span className=\"whitespace-nowrap font-medium text-sm\">\n                    {month}\n                  </span>\n                </div>\n              ))}\n            </motion.div>\n          </div>\n\n          {/* Day stack */}\n          <div className=\"relative h-6 overflow-hidden\">\n            <motion.div className=\"flex flex-col\" style={{ y: dayY }}>\n              {parsedLabels.map((label, index) => (\n                <div\n                  className=\"flex h-6 shrink-0 items-center justify-center\"\n                  key={`${label.day}-${index}`}\n                >\n                  <span className=\"whitespace-nowrap font-medium text-sm\">\n                    {label.day}\n                  </span>\n                </div>\n              ))}\n            </motion.div>\n          </div>\n        </div>\n      </div>\n    </motion.div>\n  );\n}\n\nDateTicker.displayName = \"DateTicker\";\n\nexport default DateTicker;\n",
      "type": "registry:component",
      "target": "components/charts/tooltip/date-ticker.tsx"
    },
    {
      "path": "src/charts/tooltip/index.ts",
      "content": "export { ChartTooltip, type ChartTooltipProps } from \"./chart-tooltip\";\nexport { DateTicker, type DateTickerProps } from \"./date-ticker\";\nexport { TooltipBox, type TooltipBoxProps } from \"./tooltip-box\";\nexport {\n  TooltipContent,\n  type TooltipContentProps,\n  type TooltipRow,\n} from \"./tooltip-content\";\nexport { TooltipDot, type TooltipDotProps } from \"./tooltip-dot\";\nexport {\n  type IndicatorWidth,\n  TooltipIndicator,\n  type TooltipIndicatorProps,\n} from \"./tooltip-indicator\";\n",
      "type": "registry:component",
      "target": "components/charts/tooltip/index.ts"
    }
  ]
}