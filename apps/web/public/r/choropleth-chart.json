{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "choropleth-chart",
  "type": "registry:component",
  "title": "Choropleth Map",
  "description": "A geographic map chart with zoom, pan, and data visualization",
  "dependencies": [
    "@visx/geo",
    "@visx/responsive",
    "@visx/zoom",
    "d3-geo",
    "topojson-client",
    "motion"
  ],
  "registryDependencies": [
    "https://ui.bklit.com/r/utils.json"
  ],
  "files": [
    {
      "path": "src/charts/choropleth/choropleth-chart.tsx",
      "content": "\"use client\";\n\nimport { Mercator } from \"@visx/geo\";\nimport { ParentSize } from \"@visx/responsive\";\nimport { Zoom } from \"@visx/zoom\";\nimport type { TransformMatrix } from \"@visx/zoom/lib/types\";\nimport type { FeatureCollection, Geometry } from \"geojson\";\nimport React, {\n  type ReactNode,\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport { cn } from \"../../lib/utils\";\nimport {\n  type ChoroplethFeatureProperties,\n  ChoroplethProvider,\n  type ChoroplethTooltipData,\n  ChoroplethZoomContext,\n  type Margin,\n  type ZoomInstance,\n} from \"./choropleth-context\";\n\nexport interface ChoroplethChartProps {\n  /** GeoJSON FeatureCollection data */\n  data: FeatureCollection<Geometry, ChoroplethFeatureProperties>;\n  /** Chart margins */\n  margin?: Partial<Margin>;\n  /** Animation duration in milliseconds. Default: 800 */\n  animationDuration?: number;\n  /** Aspect ratio as \"width / height\". Default: \"16 / 9\" */\n  aspectRatio?: string;\n  /** Projection scale. If not provided, auto-calculated based on width */\n  scale?: number;\n  /** Center coordinates [longitude, latitude]. Default: [0, 20] */\n  center?: [number, number];\n  /** Translate offset [x, y]. If not provided, auto-calculated to center */\n  translate?: [number, number];\n  /** Enable zoom and pan. Default: false */\n  zoomEnabled?: boolean;\n  /** Minimum zoom scale. Default: 0.5 */\n  zoomMin?: number;\n  /** Maximum zoom scale. Default: 4 */\n  zoomMax?: number;\n  /** Initial zoom transform */\n  initialZoom?: TransformMatrix;\n  /** Additional class name for the container */\n  className?: string;\n  /** Child components (ChoroplethFeature, ChoroplethGraticule, ChoroplethTooltip) */\n  children: ReactNode;\n}\n\nconst DEFAULT_MARGIN: Margin = { top: 0, right: 0, bottom: 0, left: 0 };\n\n// Known SVG component displayNames\nconst SVG_COMPONENT_NAMES = new Set([\n  \"ChoroplethFeature\",\n  \"ChoroplethGraticule\",\n  \"ChoroplethTooltip\",\n]);\n\n// HTML elements that should render in overlay layer\nconst HTML_ELEMENTS = new Set([\"div\", \"span\", \"button\", \"p\", \"a\"]);\n\n// Separate children into SVG and overlay layers\nfunction separateChildren(children: ReactNode): {\n  svgChildren: React.ReactNode[];\n  overlayChildren: React.ReactNode[];\n} {\n  const childArray = React.Children.toArray(children);\n  const svgChildren: React.ReactNode[] = [];\n  const overlayChildren: React.ReactNode[] = [];\n\n  for (const child of childArray) {\n    if (!React.isValidElement(child)) {\n      svgChildren.push(child);\n      continue;\n    }\n\n    // Check if it's a known SVG component by displayName\n    const displayName =\n      typeof child.type === \"function\"\n        ? (child.type as { displayName?: string }).displayName\n        : null;\n\n    if (displayName && SVG_COMPONENT_NAMES.has(displayName)) {\n      svgChildren.push(child);\n    } else if (typeof child.type === \"string\") {\n      // Native elements - HTML goes to overlay, SVG stays in SVG\n      if (HTML_ELEMENTS.has(child.type)) {\n        overlayChildren.push(child);\n      } else {\n        svgChildren.push(child);\n      }\n    } else {\n      // Unknown React components (like ZoomControls) go to overlay\n      overlayChildren.push(child);\n    }\n  }\n\n  return { svgChildren, overlayChildren };\n}\n\nconst DEFAULT_INITIAL_ZOOM: TransformMatrix = {\n  scaleX: 1,\n  scaleY: 1,\n  translateX: 0,\n  translateY: 0,\n  skewX: 0,\n  skewY: 0,\n};\n\nfunction ChoroplethChartInner({\n  data,\n  width,\n  height,\n  margin,\n  animationDuration,\n  scale: scaleProp,\n  center,\n  translate: translateProp,\n  zoomEnabled,\n  zoomMin,\n  zoomMax,\n  initialZoom,\n  children,\n}: {\n  data: FeatureCollection<Geometry, ChoroplethFeatureProperties>;\n  width: number;\n  height: number;\n  margin: Margin;\n  animationDuration: number;\n  scale?: number;\n  center: [number, number];\n  translate?: [number, number];\n  zoomEnabled: boolean;\n  zoomMin: number;\n  zoomMax: number;\n  initialZoom: TransformMatrix;\n  children: ReactNode;\n}) {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [isLoaded, setIsLoaded] = useState(false);\n  const [hoveredFeatureIndex, setHoveredFeatureIndex] = useState<number | null>(\n    null\n  );\n  const [tooltipData, setTooltipData] = useState<ChoroplethTooltipData | null>(\n    null\n  );\n\n  const innerWidth = width - margin.left - margin.right;\n  const innerHeight = height - margin.top - margin.bottom;\n\n  // Auto-calculate scale based on width if not provided\n  const scale = scaleProp ?? (innerWidth / 630) * 100;\n\n  // Auto-calculate translate to center if not provided\n  const translate = translateProp ?? [\n    innerWidth / 2 + margin.left,\n    innerHeight / 2 + margin.top + 50,\n  ];\n\n  useEffect(() => {\n    const timeout = setTimeout(() => {\n      setIsLoaded(true);\n    }, animationDuration);\n    return () => clearTimeout(timeout);\n  }, [animationDuration]);\n\n  const handleMouseLeave = useCallback(() => {\n    setHoveredFeatureIndex(null);\n    setTooltipData(null);\n  }, []);\n\n  if (width < 10 || height < 10) {\n    return null;\n  }\n\n  return (\n    <Mercator\n      center={center}\n      data={data.features}\n      scale={scale}\n      translate={translate as [number, number]}\n    >\n      {(mercator) => {\n        // Project geo coordinates to screen coordinates using the projection\n        const projectPoint = (\n          coords: [number, number]\n        ): [number, number] | null => {\n          const projected = mercator.projection(coords);\n          if (!projected) {\n            return null;\n          }\n          return projected as [number, number];\n        };\n\n        const contextValue = {\n          features: data.features,\n          featureCollection: data,\n          pathGenerator: (feature: (typeof data.features)[0]) =>\n            mercator.path(feature) ?? undefined,\n          // biome-ignore lint/suspicious/noExplicitAny: GeoJSON types are complex\n          rawPathGenerator: (geo: any) => mercator.path(geo),\n          projectPoint,\n          width,\n          height,\n          innerWidth,\n          innerHeight,\n          margin,\n          hoveredFeatureIndex,\n          setHoveredFeatureIndex,\n          tooltipData,\n          setTooltipData,\n          containerRef,\n          isLoaded,\n          animationDuration,\n        };\n\n        // Separate SVG children from HTML overlay children\n        const { svgChildren, overlayChildren } = separateChildren(children);\n\n        const svgContent = (zoom?: ZoomInstance<SVGSVGElement>) => (\n          <ChoroplethZoomContext.Provider value={{ zoom: zoom ?? null }}>\n            <ChoroplethProvider value={contextValue}>\n              <div className=\"relative h-full w-full\" ref={containerRef}>\n                <svg\n                  aria-hidden=\"true\"\n                  height={height}\n                  onMouseLeave={handleMouseLeave}\n                  ref={zoom?.containerRef}\n                  style={{\n                    cursor: zoom?.isDragging ? \"grabbing\" : \"grab\",\n                    touchAction: \"none\",\n                  }}\n                  width={width}\n                >\n                  <g\n                    style={{\n                      transition: zoom?.isDragging\n                        ? \"none\"\n                        : \"transform 0.18s ease-out\",\n                    }}\n                    transform={zoom ? zoom.toString() : undefined}\n                  >\n                    {svgChildren}\n                  </g>\n                </svg>\n                {/* HTML overlay layer for controls, legends, etc. */}\n                {overlayChildren}\n              </div>\n            </ChoroplethProvider>\n          </ChoroplethZoomContext.Provider>\n        );\n\n        if (zoomEnabled) {\n          return (\n            <Zoom<SVGSVGElement>\n              height={height}\n              initialTransformMatrix={initialZoom}\n              scaleXMax={zoomMax}\n              scaleXMin={zoomMin}\n              scaleYMax={zoomMax}\n              scaleYMin={zoomMin}\n              wheelDelta={(event) => {\n                // Reduce zoom sensitivity (default is too aggressive)\n                const scale = event.deltaY > 0 ? 0.95 : 1.05;\n                return { scaleX: scale, scaleY: scale };\n              }}\n              width={width}\n            >\n              {(zoom) => svgContent(zoom)}\n            </Zoom>\n          );\n        }\n\n        return svgContent();\n      }}\n    </Mercator>\n  );\n}\n\nexport function ChoroplethChart({\n  data,\n  margin: marginProp,\n  animationDuration = 800,\n  aspectRatio = \"16 / 9\",\n  scale,\n  center = [0, 20],\n  translate,\n  zoomEnabled = false,\n  zoomMin = 0.5,\n  zoomMax = 4,\n  initialZoom = DEFAULT_INITIAL_ZOOM,\n  className = \"\",\n  children,\n}: ChoroplethChartProps) {\n  const margin = { ...DEFAULT_MARGIN, ...marginProp };\n\n  return (\n    <div className={cn(\"relative w-full\", className)} style={{ aspectRatio }}>\n      <ParentSize>\n        {({ width, height }) =>\n          width > 0 && height > 0 ? (\n            <ChoroplethChartInner\n              animationDuration={animationDuration}\n              center={center}\n              data={data}\n              height={height}\n              initialZoom={initialZoom}\n              margin={margin}\n              scale={scale}\n              translate={translate}\n              width={width}\n              zoomEnabled={zoomEnabled}\n              zoomMax={zoomMax}\n              zoomMin={zoomMin}\n            >\n              {children}\n            </ChoroplethChartInner>\n          ) : null\n        }\n      </ParentSize>\n    </div>\n  );\n}\n\nChoroplethChart.displayName = \"ChoroplethChart\";\n\nexport default ChoroplethChart;\n",
      "type": "registry:component",
      "target": "components/charts/choropleth/choropleth-chart.tsx"
    },
    {
      "path": "src/charts/choropleth/choropleth-context.tsx",
      "content": "\"use client\";\n\nimport type { ProvidedZoom, TransformMatrix } from \"@visx/zoom/lib/types\";\nimport type { Feature, FeatureCollection, Geometry } from \"geojson\";\nimport {\n  createContext,\n  type Dispatch,\n  type RefObject,\n  type SetStateAction,\n  useContext,\n} from \"react\";\n\n// ZoomState from visx/zoom that includes isDragging\ninterface ZoomState {\n  initialTransformMatrix: TransformMatrix;\n  transformMatrix: TransformMatrix;\n  isDragging: boolean;\n}\n\n// Combined type from visx Zoom children prop\nexport type ZoomInstance<E extends Element> = ProvidedZoom<E> & ZoomState;\n\n// Zoom context to share zoom controls with child components\ninterface ChoroplethZoomContextValue {\n  zoom: ZoomInstance<SVGSVGElement> | null;\n}\n\nexport const ChoroplethZoomContext = createContext<ChoroplethZoomContextValue>({\n  zoom: null,\n});\n\nexport function useChoroplethZoom() {\n  return useContext(ChoroplethZoomContext);\n}\n\nexport interface Margin {\n  top: number;\n  right: number;\n  bottom: number;\n  left: number;\n}\n\nexport interface ChoroplethFeatureProperties {\n  name?: string;\n  id?: string | number;\n  [key: string]: unknown;\n}\n\nexport type ChoroplethFeature = Feature<Geometry, ChoroplethFeatureProperties>;\n\nexport interface ChoroplethTooltipData {\n  featureIndex: number;\n  x: number;\n  y: number;\n  feature: ChoroplethFeature;\n}\n\nexport interface ChoroplethContextValue {\n  // Geo data\n  features: ChoroplethFeature[];\n  featureCollection: FeatureCollection<Geometry, ChoroplethFeatureProperties>;\n\n  // Projection function (returns path string)\n  pathGenerator: (feature: ChoroplethFeature) => string | undefined;\n\n  // Raw path function for graticule (accepts any geo object)\n  // biome-ignore lint/suspicious/noExplicitAny: GeoJSON types are complex\n  rawPathGenerator: (geo: any) => string | null;\n\n  // Project geo coordinates to screen coordinates\n  projectPoint: (coords: [number, number]) => [number, number] | null;\n\n  // Dimensions\n  width: number;\n  height: number;\n  innerWidth: number;\n  innerHeight: number;\n  margin: Margin;\n\n  // Hover state\n  hoveredFeatureIndex: number | null;\n  setHoveredFeatureIndex: (index: number | null) => void;\n\n  // Tooltip\n  tooltipData: ChoroplethTooltipData | null;\n  setTooltipData: Dispatch<SetStateAction<ChoroplethTooltipData | null>>;\n  containerRef: RefObject<HTMLDivElement | null>;\n\n  // Animation\n  isLoaded: boolean;\n  animationDuration: number;\n}\n\nconst ChoroplethContext = createContext<ChoroplethContextValue | null>(null);\n\nexport function ChoroplethProvider({\n  children,\n  value,\n}: {\n  children: React.ReactNode;\n  value: ChoroplethContextValue;\n}) {\n  return (\n    <ChoroplethContext.Provider value={value}>\n      {children}\n    </ChoroplethContext.Provider>\n  );\n}\n\nexport function useChoropleth(): ChoroplethContextValue {\n  const context = useContext(ChoroplethContext);\n  if (!context) {\n    throw new Error(\"useChoropleth must be used within a ChoroplethProvider\");\n  }\n  return context;\n}\n\n// CSS variables for choropleth theming\nexport const choroplethCssVars = {\n  feature1: \"var(--chart-1)\",\n  feature2: \"var(--chart-2)\",\n  feature3: \"var(--chart-3)\",\n  feature4: \"var(--chart-4)\",\n  feature5: \"var(--chart-5)\",\n  stroke: \"var(--chart-grid)\",\n  background: \"var(--background)\",\n};\n\n// Default colors array for cycling through features\nexport const defaultChoroplethColors = [\n  \"var(--chart-1)\",\n  \"var(--chart-2)\",\n  \"var(--chart-3)\",\n  \"var(--chart-4)\",\n  \"var(--chart-5)\",\n];\n",
      "type": "registry:component",
      "target": "components/charts/choropleth/choropleth-context.tsx"
    },
    {
      "path": "src/charts/choropleth/choropleth-feature.tsx",
      "content": "\"use client\";\n\nimport { geoCentroid } from \"d3-geo\";\nimport { motion } from \"motion/react\";\nimport { useCallback, useMemo } from \"react\";\nimport {\n  type ChoroplethFeature as ChoroplethFeatureType,\n  defaultChoroplethColors,\n  useChoropleth,\n} from \"./choropleth-context\";\n\nexport interface ChoroplethFeatureProps {\n  /** Fill color for all features (overrides getFeatureColor). Default: uses getFeatureColor or chart-1 */\n  fill?: string;\n  /** Stroke color for feature borders. Default: var(--chart-grid) */\n  stroke?: string;\n  /** Stroke width for feature borders. Default: 0.5 */\n  strokeWidth?: number;\n  /** Opacity when another feature is hovered. Default: 0.4 */\n  fadedOpacity?: number;\n  /** Custom function to get feature fill color */\n  getFeatureColor?: (feature: ChoroplethFeatureType, index: number) => string;\n  /** Pattern definitions to render in defs. Use @visx/pattern components (PatternLines, PatternCircles, etc.) */\n  patterns?: React.ReactNode;\n  /** Return pattern ID for a feature, or null/undefined to use solid fill */\n  getFeaturePattern?: (\n    feature: ChoroplethFeatureType,\n    index: number\n  ) => string | null | undefined;\n}\n\ninterface AnimatedFeaturePathProps {\n  path: string;\n  fill: string;\n  stroke: string;\n  strokeWidth: number;\n  isFaded: boolean;\n  isHighlighted: boolean;\n  fadedOpacity: number;\n  animationDuration: number;\n  index: number;\n  totalFeatures: number;\n  onMouseEnter: () => void;\n  onMouseLeave: () => void;\n}\n\nfunction AnimatedFeaturePath({\n  path,\n  fill,\n  stroke,\n  strokeWidth,\n  isFaded,\n  isHighlighted,\n  fadedOpacity,\n  animationDuration,\n  index,\n  totalFeatures,\n  onMouseEnter,\n  onMouseLeave,\n}: AnimatedFeaturePathProps) {\n  // Calculate stagger delay based on feature index\n  const staggerDelay = (index / totalFeatures) * animationDuration * 0.5;\n\n  // Calculate target opacity - slightly boost highlighted features\n  const getTargetOpacity = () => {\n    if (isFaded) {\n      return fadedOpacity;\n    }\n    if (isHighlighted) {\n      return 1;\n    }\n    return 0.85;\n  };\n  const targetOpacity = getTargetOpacity();\n\n  return (\n    <motion.path\n      animate={{ opacity: targetOpacity }}\n      className=\"cursor-pointer\"\n      d={path}\n      fill={fill}\n      initial={{ opacity: 0 }}\n      onMouseEnter={onMouseEnter}\n      onMouseLeave={onMouseLeave}\n      stroke={stroke}\n      strokeWidth={strokeWidth}\n      transition={{\n        opacity: { duration: 0.18, ease: \"easeOut\" },\n        default: {\n          duration: animationDuration / 1000,\n          delay: staggerDelay / 1000,\n        },\n      }}\n    />\n  );\n}\n\nexport function ChoroplethFeature({\n  fill,\n  stroke = \"var(--background)\",\n  strokeWidth = 0.5,\n  fadedOpacity = 0.4,\n  getFeatureColor,\n  patterns,\n  getFeaturePattern,\n}: ChoroplethFeatureProps) {\n  const {\n    features,\n    pathGenerator,\n    projectPoint,\n    hoveredFeatureIndex,\n    setHoveredFeatureIndex,\n    setTooltipData,\n    animationDuration,\n    width,\n    height,\n  } = useChoropleth();\n\n  // Pre-calculate centroids for all features (only recalculates when features change)\n  const featureCentroids = useMemo(() => {\n    return features.map((feature) => {\n      try {\n        const centroid = geoCentroid(feature);\n        if (\n          centroid &&\n          !Number.isNaN(centroid[0]) &&\n          !Number.isNaN(centroid[1])\n        ) {\n          const projected = projectPoint(centroid as [number, number]);\n          if (projected) {\n            // Clamp to chart bounds with padding\n            const padding = 60;\n            const x = Math.max(\n              padding,\n              Math.min(width - padding, projected[0])\n            );\n            const y = Math.max(\n              padding,\n              Math.min(height - padding, projected[1])\n            );\n            return { x, y };\n          }\n        }\n      } catch {\n        // Some geometries may not have valid centroids\n      }\n      return null;\n    });\n  }, [features, projectPoint, width, height]);\n\n  // Get color for a feature\n  const getFeatureColorFn = useCallback(\n    (feature: ChoroplethFeatureType, index: number): string => {\n      if (fill) {\n        return fill;\n      }\n      if (getFeatureColor) {\n        return getFeatureColor(feature, index);\n      }\n      // Default: use chart colors cycling through\n      return (\n        defaultChoroplethColors[index % defaultChoroplethColors.length] ??\n        \"var(--chart-1)\"\n      );\n    },\n    [fill, getFeatureColor]\n  );\n\n  // Check if any element is hovered\n  const isAnyHovered = hoveredFeatureIndex !== null;\n\n  return (\n    <g className=\"choropleth-features\">\n      {/* Pattern definitions */}\n      {patterns && <defs>{patterns}</defs>}\n\n      {/* Feature paths */}\n      {features.map((feature, index) => {\n        const path = pathGenerator(feature);\n\n        // Skip if path is empty or undefined\n        if (!path || path.trim() === \"\") {\n          return null;\n        }\n\n        const isHighlighted = hoveredFeatureIndex === index;\n        const isFaded = isAnyHovered && !isHighlighted;\n\n        // Get pre-calculated centroid for tooltip positioning\n        const centroid = featureCentroids[index];\n\n        const handleMouseEnter = () => {\n          setHoveredFeatureIndex(index);\n          setTooltipData({\n            featureIndex: index,\n            x: centroid?.x ?? width / 2,\n            y: centroid?.y ?? height / 2,\n            feature,\n          });\n        };\n\n        const handleMouseLeave = () => {\n          setHoveredFeatureIndex(null);\n          setTooltipData(null);\n        };\n\n        // Determine fill (pattern URL or solid color)\n        let featureFill: string;\n        const patternId = getFeaturePattern?.(feature, index);\n        if (patternId) {\n          featureFill = `url(#${patternId})`;\n        } else {\n          featureFill = getFeatureColorFn(feature, index);\n        }\n\n        return (\n          <AnimatedFeaturePath\n            animationDuration={animationDuration}\n            fadedOpacity={fadedOpacity}\n            fill={featureFill}\n            index={index}\n            isFaded={isFaded}\n            isHighlighted={isHighlighted}\n            key={`feature-${index}-${feature.properties?.name ?? feature.properties?.id ?? index}`}\n            onMouseEnter={handleMouseEnter}\n            onMouseLeave={handleMouseLeave}\n            path={path}\n            stroke={stroke}\n            strokeWidth={strokeWidth}\n            totalFeatures={features.length}\n          />\n        );\n      })}\n    </g>\n  );\n}\n\nChoroplethFeature.displayName = \"ChoroplethFeature\";\n\nexport default ChoroplethFeature;\n",
      "type": "registry:component",
      "target": "components/charts/choropleth/choropleth-feature.tsx"
    },
    {
      "path": "src/charts/choropleth/choropleth-graticule.tsx",
      "content": "\"use client\";\n\nimport { Graticule } from \"@visx/geo\";\nimport { useChoropleth } from \"./choropleth-context\";\n\nexport interface ChoroplethGraticuleProps {\n  /** Stroke color for graticule lines. Default: rgba(255,255,255,0.1) */\n  stroke?: string;\n  /** Stroke width for graticule lines. Default: 0.5 */\n  strokeWidth?: number;\n  /** Step intervals for graticule lines [longitude, latitude] in degrees. Default: [10, 10] */\n  step?: [number, number];\n}\n\nexport function ChoroplethGraticule({\n  stroke = \"rgba(255,255,255,0.1)\",\n  strokeWidth = 0.5,\n  step,\n}: ChoroplethGraticuleProps) {\n  const { rawPathGenerator } = useChoropleth();\n\n  return (\n    <Graticule\n      graticule={(g) => rawPathGenerator(g) || \"\"}\n      step={step}\n      stroke={stroke}\n      strokeWidth={strokeWidth}\n    />\n  );\n}\n\nChoroplethGraticule.displayName = \"ChoroplethGraticule\";\n\nexport default ChoroplethGraticule;\n",
      "type": "registry:component",
      "target": "components/charts/choropleth/choropleth-graticule.tsx"
    },
    {
      "path": "src/charts/choropleth/choropleth-tooltip.tsx",
      "content": "\"use client\";\n\nimport { TooltipBox } from \"../tooltip/tooltip-box\";\nimport { TooltipContent, type TooltipRow } from \"../tooltip/tooltip-content\";\nimport {\n  type ChoroplethFeature,\n  useChoropleth,\n  useChoroplethZoom,\n} from \"./choropleth-context\";\n\nexport interface ChoroplethTooltipProps {\n  /** Custom content renderer for feature tooltips */\n  content?: (props: {\n    feature: ChoroplethFeature;\n    index: number;\n  }) => React.ReactNode;\n  /** Value formatter function */\n  formatValue?: (value: number) => string;\n  /** Get the display name for a feature. Default: uses feature.properties.name */\n  getFeatureName?: (feature: ChoroplethFeature, index: number) => string;\n  /** Get the value for a feature (for display in tooltip) */\n  getFeatureValue?: (\n    feature: ChoroplethFeature,\n    index: number\n  ) => number | undefined;\n  /** Label for the value row. Default: \"Value\" */\n  valueLabel?: string;\n  /** Custom class name */\n  className?: string;\n}\n\nexport function ChoroplethTooltip({\n  content,\n  formatValue = (v) => v.toLocaleString(),\n  getFeatureName,\n  getFeatureValue,\n  valueLabel = \"Value\",\n  className = \"\",\n}: ChoroplethTooltipProps) {\n  const { tooltipData, containerRef, width, height, features } =\n    useChoropleth();\n  const { zoom } = useChoroplethZoom();\n\n  if (!tooltipData) {\n    return null;\n  }\n\n  // Apply zoom transform to centroid position\n  let x = tooltipData.x;\n  let y = tooltipData.y;\n\n  if (zoom) {\n    // Apply the zoom transform matrix to the tooltip position\n    const transformed = zoom.applyToPoint({ x, y });\n    x = transformed.x;\n    y = transformed.y;\n  }\n\n  const feature = features[tooltipData.featureIndex];\n  if (!feature) {\n    return null;\n  }\n\n  // Get feature name\n  const featureName = getFeatureName\n    ? getFeatureName(feature, tooltipData.featureIndex)\n    : (feature.properties?.name ?? `Feature ${tooltipData.featureIndex}`);\n\n  // Custom content\n  if (content) {\n    return (\n      <TooltipBox\n        className={className}\n        containerHeight={height}\n        containerRef={containerRef}\n        containerWidth={width}\n        visible\n        x={x}\n        y={y}\n      >\n        {content({ feature, index: tooltipData.featureIndex })}\n      </TooltipBox>\n    );\n  }\n\n  // Default tooltip with optional value\n  const value = getFeatureValue?.(feature, tooltipData.featureIndex);\n  const rows: TooltipRow[] =\n    value !== undefined\n      ? [\n          {\n            color: \"var(--chart-1)\",\n            label: valueLabel,\n            value: formatValue(value),\n          },\n        ]\n      : [];\n\n  return (\n    <TooltipBox\n      className={className}\n      containerHeight={height}\n      containerRef={containerRef}\n      containerWidth={width}\n      visible\n      x={x}\n      y={y}\n    >\n      <TooltipContent rows={rows} title={featureName} />\n    </TooltipBox>\n  );\n}\n\nChoroplethTooltip.displayName = \"ChoroplethTooltip\";\n\nexport default ChoroplethTooltip;\n",
      "type": "registry:component",
      "target": "components/charts/choropleth/choropleth-tooltip.tsx"
    },
    {
      "path": "src/charts/choropleth/index.ts",
      "content": "export type { TransformMatrix } from \"@visx/zoom/lib/types\";\nexport { ChoroplethChart, type ChoroplethChartProps } from \"./choropleth-chart\";\nexport {\n  type ChoroplethContextValue,\n  type ChoroplethFeature,\n  type ChoroplethFeatureProperties,\n  ChoroplethProvider,\n  type ChoroplethTooltipData,\n  choroplethCssVars,\n  defaultChoroplethColors,\n  type Margin,\n  useChoropleth,\n  useChoroplethZoom,\n} from \"./choropleth-context\";\nexport {\n  ChoroplethFeature as ChoroplethFeatureComponent,\n  type ChoroplethFeatureProps,\n} from \"./choropleth-feature\";\nexport {\n  ChoroplethGraticule,\n  type ChoroplethGraticuleProps,\n} from \"./choropleth-graticule\";\nexport {\n  ChoroplethTooltip,\n  type ChoroplethTooltipProps,\n} from \"./choropleth-tooltip\";\n",
      "type": "registry:component",
      "target": "components/charts/choropleth/index.ts"
    }
  ]
}