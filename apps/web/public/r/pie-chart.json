{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "pie-chart",
  "type": "registry:component",
  "title": "Pie Chart",
  "description": "A composable pie chart with animations and customizable slices",
  "dependencies": [
    "@visx/responsive",
    "@visx/shape",
    "motion"
  ],
  "registryDependencies": [
    "https://ui.bklit.com/r/utils.json"
  ],
  "files": [
    {
      "path": "src/charts/pie-chart.tsx",
      "content": "\"use client\";\n\nimport { Group } from \"@visx/group\";\nimport { ParentSize } from \"@visx/responsive\";\nimport { pie as d3Pie } from \"d3-shape\";\nimport {\n  Children,\n  isValidElement,\n  type ReactElement,\n  type ReactNode,\n  useCallback,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport { cn } from \"../lib/utils\";\nimport {\n  defaultPieColors,\n  type PieArcData,\n  type PieContextValue,\n  type PieData,\n  PieProvider,\n} from \"./pie-context\";\n\n/** Default hover offset in pixels */\nexport const DEFAULT_HOVER_OFFSET = 10;\n\nexport interface PieChartProps {\n  /** Data array - each item represents a slice */\n  data: PieData[];\n  /** Chart size in pixels. If not provided, uses parent container size */\n  size?: number;\n  /** Inner radius for donut charts. Default: 0 (solid pie) */\n  innerRadius?: number;\n  /** Padding angle between slices in radians. Default: 0 */\n  padAngle?: number;\n  /** Corner radius for rounded slice edges. Default: 0 */\n  cornerRadius?: number;\n  /** Start angle in radians. Default: -PI/2 (top) */\n  startAngle?: number;\n  /** End angle in radians. Default: 3*PI/2 (full circle from top) */\n  endAngle?: number;\n  /** Additional class name for the container */\n  className?: string;\n  /** Controlled hover state - index of hovered slice */\n  hoveredIndex?: number | null;\n  /** Callback when hover state changes */\n  onHoverChange?: (index: number | null) => void;\n  /**\n   * Hover offset in pixels for slice hover effects.\n   * This also determines the padding around the chart to prevent clipping.\n   * Default: 10\n   */\n  hoverOffset?: number;\n  /** Child components (PieSlice, PieCenter, patterns, gradients, etc.) */\n  children: ReactNode;\n}\n\ninterface PieChartInnerProps {\n  width: number;\n  height: number;\n  data: PieData[];\n  innerRadius: number;\n  padAngle: number;\n  cornerRadius: number;\n  startAngle: number;\n  endAngle: number;\n  hoverOffset: number;\n  children: ReactNode;\n  containerRef: React.RefObject<HTMLDivElement | null>;\n  hoveredIndexProp?: number | null;\n  onHoverChange?: (index: number | null) => void;\n}\n\n// Helper to check if a child is a PieCenter component\nfunction isPieCenter(child: ReactNode): boolean {\n  return (\n    isValidElement(child) &&\n    typeof child.type === \"function\" &&\n    ((child.type as { displayName?: string }).displayName === \"PieCenter\" ||\n      (child.type as { name?: string }).name === \"PieCenter\")\n  );\n}\n\n// Helper to check if a component is a gradient or pattern definition\nfunction isDefsComponent(child: ReactElement): boolean {\n  const displayName =\n    (child.type as { displayName?: string })?.displayName ||\n    (child.type as { name?: string })?.name ||\n    \"\";\n  return (\n    displayName.includes(\"Gradient\") ||\n    displayName.includes(\"Pattern\") ||\n    displayName === \"LinearGradient\" ||\n    displayName === \"RadialGradient\"\n  );\n}\n\nfunction PieChartInner({\n  width,\n  height,\n  data,\n  innerRadius: innerRadiusProp,\n  padAngle,\n  cornerRadius,\n  startAngle,\n  endAngle,\n  hoverOffset,\n  children,\n  containerRef,\n  hoveredIndexProp,\n  onHoverChange,\n}: PieChartInnerProps) {\n  const [internalHoveredIndex, setInternalHoveredIndex] = useState<\n    number | null\n  >(null);\n  const [animationKey] = useState(0);\n  const [isLoaded, setIsLoaded] = useState(false);\n\n  // Use controlled or uncontrolled hover state\n  const isControlled = hoveredIndexProp !== undefined;\n  const hoveredIndex = isControlled ? hoveredIndexProp : internalHoveredIndex;\n  const setHoveredIndex = useCallback(\n    (index: number | null) => {\n      if (isControlled) {\n        onHoverChange?.(index);\n      } else {\n        setInternalHoveredIndex(index);\n      }\n    },\n    [isControlled, onHoverChange]\n  );\n\n  // Use the smaller dimension to ensure the chart fits\n  const size = Math.min(width, height);\n  const center = size / 2;\n\n  // Calculate radii with padding based on hover offset to prevent clipping\n  const padding = hoverOffset;\n  const outerRadius = center - padding;\n  const innerRadius = innerRadiusProp;\n\n  // Calculate total value\n  const totalValue = useMemo(\n    () => data.reduce((sum, d) => sum + d.value, 0),\n    [data]\n  );\n\n  // Get color for a slice index\n  const getColor = useCallback(\n    (index: number) => {\n      const item = data[index];\n      if (item?.color) {\n        return item.color;\n      }\n      return defaultPieColors[index % defaultPieColors.length] as string;\n    },\n    [data]\n  );\n\n  // Get fill for a slice index (supports patterns/gradients)\n  const getFill = useCallback(\n    (index: number) => {\n      const item = data[index];\n      // Check for explicit fill (pattern/gradient URL)\n      if (item?.fill) {\n        return item.fill;\n      }\n      // Fall back to color\n      return getColor(index);\n    },\n    [data, getColor]\n  );\n\n  // Compute arcs using d3-shape pie\n  const arcs = useMemo(() => {\n    const pieGenerator = d3Pie<PieData>()\n      .value((d) => d.value)\n      .startAngle(startAngle)\n      .endAngle(endAngle)\n      .padAngle(padAngle)\n      .sort(null); // Maintain data order\n\n    const computed = pieGenerator(data);\n\n    return computed.map((arc, index) => ({\n      data: arc.data,\n      index,\n      startAngle: arc.startAngle,\n      endAngle: arc.endAngle,\n      padAngle: arc.padAngle,\n      value: arc.value,\n    })) as PieArcData[];\n  }, [data, startAngle, endAngle, padAngle]);\n\n  // Mark as loaded after initial render\n  useState(() => {\n    const timer = setTimeout(() => {\n      setIsLoaded(true);\n    }, 100);\n    return () => clearTimeout(timer);\n  });\n\n  // Separate children into categories\n  const { svgChildren, centerChildren, defsChildren } = useMemo(() => {\n    const svgNodes: ReactNode[] = [];\n    const centerNodes: ReactNode[] = [];\n    const defsNodes: ReactElement[] = [];\n\n    Children.forEach(children, (child) => {\n      if (!isValidElement(child)) {\n        svgNodes.push(child);\n        return;\n      }\n\n      if (isPieCenter(child)) {\n        centerNodes.push(child);\n      } else if (isDefsComponent(child)) {\n        defsNodes.push(child);\n      } else {\n        svgNodes.push(child);\n      }\n    });\n\n    return {\n      svgChildren: svgNodes,\n      centerChildren: centerNodes,\n      defsChildren: defsNodes,\n    };\n  }, [children]);\n\n  // Early return if dimensions not ready\n  if (size < 10) {\n    return null;\n  }\n\n  const contextValue: PieContextValue = {\n    data,\n    arcs,\n    size,\n    center,\n    outerRadius,\n    innerRadius,\n    padAngle,\n    cornerRadius,\n    hoverOffset,\n    hoveredIndex,\n    setHoveredIndex,\n    animationKey,\n    isLoaded,\n    containerRef,\n    totalValue,\n    getColor,\n    getFill,\n  };\n\n  // Use CSS Grid stacking to layer SVG and HTML content\n  // This avoids Safari's foreignObject rendering bugs\n  return (\n    <PieProvider value={contextValue}>\n      <div\n        className=\"grid\"\n        style={{\n          gridTemplateColumns: \"1fr\",\n          gridTemplateRows: \"1fr\",\n          width: size,\n          height: size,\n        }}\n      >\n        {/* SVG layer with pie slices */}\n        <svg\n          aria-hidden=\"true\"\n          height={size}\n          style={{ gridArea: \"1 / 1\" }}\n          width={size}\n        >\n          {/* Defs for patterns and gradients */}\n          {defsChildren.length > 0 && <defs>{defsChildren}</defs>}\n\n          <Group left={center} top={center}>\n            {svgChildren}\n          </Group>\n        </svg>\n\n        {/* HTML layer with center content - stacked on top via grid */}\n        {centerChildren.length > 0 && (\n          <div\n            className=\"pointer-events-none flex items-center justify-center\"\n            style={{ gridArea: \"1 / 1\" }}\n          >\n            {centerChildren}\n          </div>\n        )}\n      </div>\n    </PieProvider>\n  );\n}\n\nexport function PieChart({\n  data,\n  size: fixedSize,\n  innerRadius = 0,\n  padAngle = 0,\n  cornerRadius = 0,\n  startAngle = -Math.PI / 2,\n  endAngle = (3 * Math.PI) / 2,\n  className = \"\",\n  hoveredIndex,\n  onHoverChange,\n  hoverOffset = DEFAULT_HOVER_OFFSET,\n  children,\n}: PieChartProps) {\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  // If fixed size is provided, use it directly\n  if (fixedSize) {\n    return (\n      <div\n        className={cn(\"relative flex items-center justify-center\", className)}\n        ref={containerRef}\n        style={{ width: fixedSize, height: fixedSize }}\n      >\n        <PieChartInner\n          containerRef={containerRef}\n          cornerRadius={cornerRadius}\n          data={data}\n          endAngle={endAngle}\n          height={fixedSize}\n          hoveredIndexProp={hoveredIndex}\n          hoverOffset={hoverOffset}\n          innerRadius={innerRadius}\n          onHoverChange={onHoverChange}\n          padAngle={padAngle}\n          startAngle={startAngle}\n          width={fixedSize}\n        >\n          {children}\n        </PieChartInner>\n      </div>\n    );\n  }\n\n  // Otherwise use ParentSize for responsive sizing\n  return (\n    <div\n      className={cn(\"relative aspect-square w-full\", className)}\n      ref={containerRef}\n    >\n      <ParentSize debounceTime={10}>\n        {({ width, height }) => (\n          <PieChartInner\n            containerRef={containerRef}\n            cornerRadius={cornerRadius}\n            data={data}\n            endAngle={endAngle}\n            height={height}\n            hoveredIndexProp={hoveredIndex}\n            hoverOffset={hoverOffset}\n            innerRadius={innerRadius}\n            onHoverChange={onHoverChange}\n            padAngle={padAngle}\n            startAngle={startAngle}\n            width={width}\n          >\n            {children}\n          </PieChartInner>\n        )}\n      </ParentSize>\n    </div>\n  );\n}\n\nPieChart.displayName = \"PieChart\";\n\nexport default PieChart;\n",
      "type": "registry:component",
      "target": "components/charts/pie-chart.tsx"
    },
    {
      "path": "src/charts/pie-context.tsx",
      "content": "\"use client\";\n\nimport { createContext, type RefObject, useContext } from \"react\";\n\n// CSS variable references for pie chart theming\nexport const pieCssVars = {\n  background: \"var(--chart-background)\",\n  foreground: \"var(--chart-foreground)\",\n  foregroundMuted: \"var(--chart-foreground-muted)\",\n  label: \"var(--chart-label)\",\n  // Default slice colors from chart palette\n  slice1: \"var(--chart-1)\",\n  slice2: \"var(--chart-2)\",\n  slice3: \"var(--chart-3)\",\n  slice4: \"var(--chart-4)\",\n  slice5: \"var(--chart-5)\",\n};\n\n// Default slice color palette\nexport const defaultPieColors = [\n  pieCssVars.slice1,\n  pieCssVars.slice2,\n  pieCssVars.slice3,\n  pieCssVars.slice4,\n  pieCssVars.slice5,\n];\n\nexport interface PieData {\n  /** Display label for the slice */\n  label: string;\n  /** Value for the slice (determines slice size relative to total) */\n  value: number;\n  /** Optional color override - falls back to palette */\n  color?: string;\n  /** Optional fill override for patterns/gradients (e.g., \"url(#patternId)\") */\n  fill?: string;\n}\n\n/** Arc data computed by visx Pie */\nexport interface PieArcData {\n  data: PieData;\n  index: number;\n  startAngle: number;\n  endAngle: number;\n  padAngle: number;\n  value: number;\n}\n\nexport interface PieContextValue {\n  // Data\n  data: PieData[];\n  arcs: PieArcData[];\n\n  // Dimensions\n  size: number;\n  center: number;\n  outerRadius: number;\n  innerRadius: number;\n  padAngle: number;\n  cornerRadius: number;\n\n  // Hover effect\n  hoverOffset: number;\n\n  // Hover state\n  hoveredIndex: number | null;\n  setHoveredIndex: (index: number | null) => void;\n\n  // Animation state\n  animationKey: number;\n  isLoaded: boolean;\n\n  // Container ref for portals\n  containerRef: RefObject<HTMLDivElement | null>;\n\n  // Computed values\n  totalValue: number;\n\n  // Get color for a slice index\n  getColor: (index: number) => string;\n\n  // Get fill for a slice index (supports patterns/gradients)\n  getFill: (index: number) => string;\n}\n\nconst PieContext = createContext<PieContextValue | null>(null);\n\nexport function PieProvider({\n  children,\n  value,\n}: {\n  children: React.ReactNode;\n  value: PieContextValue;\n}) {\n  return <PieContext.Provider value={value}>{children}</PieContext.Provider>;\n}\n\nexport function usePie(): PieContextValue {\n  const context = useContext(PieContext);\n  if (!context) {\n    throw new Error(\n      \"usePie must be used within a PieProvider. \" +\n        \"Make sure your component is wrapped in <PieChart>.\"\n    );\n  }\n  return context;\n}\n\nexport default PieContext;\n",
      "type": "registry:component",
      "target": "components/charts/pie-context.tsx"
    },
    {
      "path": "src/charts/pie-slice.tsx",
      "content": "\"use client\";\n\nimport { arc as arcGenerator } from \"@visx/shape\";\nimport { motion, useSpring, useTransform } from \"motion/react\";\nimport { useEffect, useRef } from \"react\";\nimport { usePie } from \"./pie-context\";\n\n// Helper to generate arc path using d3 arc generator\nfunction generateArcPath(\n  innerRadius: number,\n  outerRadius: number,\n  startAngle: number,\n  endAngle: number,\n  cornerRadius: number,\n  padAngle: number\n): string {\n  const generator = arcGenerator<unknown>({\n    innerRadius,\n    outerRadius,\n    cornerRadius,\n    padAngle,\n  });\n  return generator({ startAngle, endAngle } as unknown as null) || \"\";\n}\n\n// Calculate the translation offset for a slice to \"pop out\" along its radial axis\nfunction getSliceOffset(\n  startAngle: number,\n  endAngle: number,\n  distance: number\n): { x: number; y: number } {\n  // Calculate the midpoint angle of the slice\n  const midAngle = (startAngle + endAngle) / 2;\n  // In d3-shape, 0 radians is at 12 o'clock, angles increase clockwise\n  // So the outward direction is: x = sin(angle), y = -cos(angle)\n  return {\n    x: Math.sin(midAngle) * distance,\n    y: -Math.cos(midAngle) * distance,\n  };\n}\n\n/** Hover effect types */\nexport type PieSliceHoverEffect = \"translate\" | \"grow\" | \"none\";\n\nexport interface PieSliceProps {\n  /** Index of the slice in the data array */\n  index: number;\n  /** Optional color override - falls back to data color or palette */\n  color?: string;\n  /** Optional fill override for patterns/gradients (e.g., \"url(#patternId)\") */\n  fill?: string;\n  /** Animate the slice on mount. Default: true */\n  animate?: boolean;\n  /** Show glow effect on hover. Default: true */\n  showGlow?: boolean;\n  /**\n   * Hover effect type. Default: \"translate\"\n   * - \"translate\": Slice moves outward along its radial axis\n   * - \"grow\": Slice extends its outer radius (gets longer)\n   * - \"none\": No hover animation\n   */\n  hoverEffect?: PieSliceHoverEffect;\n  /** Distance in pixels for hover effect (translate distance or grow amount). Defaults to PieChart's hoverOffset */\n  hoverOffset?: number;\n  /** Additional CSS class */\n  className?: string;\n}\n\ninterface AnimatedSliceTranslateProps {\n  index: number;\n  innerRadius: number;\n  outerRadius: number;\n  startAngle: number;\n  endAngle: number;\n  cornerRadius: number;\n  padAngle: number;\n  fill: string;\n  color: string;\n  isHovered: boolean;\n  isFaded: boolean;\n  animationKey: number;\n  showGlow: boolean;\n  hoverOffset: number;\n}\n\nfunction AnimatedSliceTranslate({\n  index,\n  innerRadius,\n  outerRadius,\n  startAngle,\n  endAngle,\n  cornerRadius,\n  padAngle,\n  fill,\n  color,\n  isHovered,\n  isFaded,\n  animationKey,\n  showGlow,\n  hoverOffset,\n}: AnimatedSliceTranslateProps) {\n  const animationDelay = 0.1 + index * 0.08;\n\n  const mountSpring = useSpring(0, {\n    stiffness: 60,\n    damping: 20,\n    restDelta: 0.001,\n  });\n\n  useEffect(() => {\n    mountSpring.jump(0);\n    const timeout = setTimeout(() => {\n      mountSpring.set(1);\n    }, animationDelay * 1000);\n    return () => clearTimeout(timeout);\n  }, [animationDelay, mountSpring]);\n\n  const animatedPath = useTransform(mountSpring, (mount) => {\n    const currentEndAngle = startAngle + (endAngle - startAngle) * mount;\n    if (currentEndAngle <= startAngle + 0.01) {\n      return \"\";\n    }\n    return generateArcPath(\n      innerRadius,\n      outerRadius,\n      startAngle,\n      currentEndAngle,\n      cornerRadius,\n      padAngle\n    );\n  });\n\n  const offset = getSliceOffset(startAngle, endAngle, hoverOffset);\n  const glowColor = color;\n\n  return (\n    <motion.path\n      animate={{\n        opacity: isFaded ? 0.4 : 1,\n        x: isHovered ? offset.x : 0,\n        y: isHovered ? offset.y : 0,\n      }}\n      d={animatedPath}\n      fill={fill}\n      key={`slice-${animationKey}-${index}`}\n      pointerEvents=\"none\"\n      style={{\n        filter:\n          showGlow && isHovered ? `drop-shadow(0 0 12px ${glowColor})` : \"none\",\n      }}\n      transition={{\n        opacity: { duration: 0.15 },\n        x: { type: \"spring\", stiffness: 400, damping: 25 },\n        y: { type: \"spring\", stiffness: 400, damping: 25 },\n      }}\n    />\n  );\n}\n\ninterface AnimatedSliceGrowProps {\n  index: number;\n  innerRadius: number;\n  outerRadius: number;\n  startAngle: number;\n  endAngle: number;\n  cornerRadius: number;\n  padAngle: number;\n  fill: string;\n  color: string;\n  isHovered: boolean;\n  isFaded: boolean;\n  animationKey: number;\n  showGlow: boolean;\n  hoverOffset: number;\n}\n\nfunction AnimatedSliceGrow({\n  index,\n  innerRadius,\n  outerRadius,\n  startAngle,\n  endAngle,\n  cornerRadius,\n  padAngle,\n  fill,\n  color,\n  isHovered,\n  isFaded,\n  animationKey,\n  showGlow,\n  hoverOffset,\n}: AnimatedSliceGrowProps) {\n  const animationDelay = 0.1 + index * 0.08;\n\n  const mountSpring = useSpring(0, {\n    stiffness: 60,\n    damping: 20,\n    restDelta: 0.001,\n  });\n\n  const growSpring = useSpring(outerRadius, {\n    stiffness: 400,\n    damping: 25,\n  });\n\n  useEffect(() => {\n    mountSpring.jump(0);\n    const timeout = setTimeout(() => {\n      mountSpring.set(1);\n    }, animationDelay * 1000);\n    return () => clearTimeout(timeout);\n  }, [animationDelay, mountSpring]);\n\n  useEffect(() => {\n    growSpring.set(isHovered ? outerRadius + hoverOffset : outerRadius);\n  }, [isHovered, hoverOffset, outerRadius, growSpring]);\n\n  const animatedPath = useTransform(\n    [mountSpring, growSpring],\n    ([mount, currentOuterRadius]) => {\n      const currentEndAngle =\n        startAngle + (endAngle - startAngle) * (mount as number);\n      if (currentEndAngle <= startAngle + 0.01) {\n        return \"\";\n      }\n      return generateArcPath(\n        innerRadius,\n        currentOuterRadius as number,\n        startAngle,\n        currentEndAngle,\n        cornerRadius,\n        padAngle\n      );\n    }\n  );\n\n  const glowColor = color;\n\n  return (\n    <motion.path\n      animate={{\n        opacity: isFaded ? 0.4 : 1,\n      }}\n      d={animatedPath}\n      fill={fill}\n      key={`slice-${animationKey}-${index}`}\n      pointerEvents=\"none\"\n      style={{\n        filter:\n          showGlow && isHovered ? `drop-shadow(0 0 12px ${glowColor})` : \"none\",\n      }}\n      transition={{\n        opacity: { duration: 0.15 },\n      }}\n    />\n  );\n}\n\nexport function PieSlice({\n  index,\n  color: colorProp,\n  fill: fillProp,\n  animate = true,\n  showGlow = true,\n  hoverEffect = \"translate\",\n  hoverOffset: hoverOffsetProp,\n}: PieSliceProps) {\n  const {\n    arcs,\n    innerRadius,\n    outerRadius,\n    cornerRadius,\n    hoverOffset: contextHoverOffset,\n    hoveredIndex,\n    setHoveredIndex,\n    animationKey,\n    getColor,\n    getFill,\n  } = usePie();\n\n  // Use prop if provided, otherwise use context value\n  const hoverOffset = hoverOffsetProp ?? contextHoverOffset;\n\n  // Track if initial mount animation is complete\n  const hasAnimated = useRef(false);\n  const sliceExpandDelay = index * 0.08;\n\n  useEffect(() => {\n    if (animate && !hasAnimated.current) {\n      const timeout = setTimeout(\n        () => {\n          hasAnimated.current = true;\n        },\n        (sliceExpandDelay + 0.5) * 1000\n      );\n      return () => clearTimeout(timeout);\n    }\n  }, [animate, sliceExpandDelay]);\n\n  const arcData = arcs[index];\n  if (!arcData) {\n    return null;\n  }\n\n  const color = colorProp || getColor(index);\n  const fill = fillProp || getFill(index);\n\n  const isHovered = hoveredIndex === index;\n  const isFaded = hoveredIndex !== null && hoveredIndex !== index;\n\n  // Calculate values for non-animated/static paths\n  const offset = getSliceOffset(\n    arcData.startAngle,\n    arcData.endAngle,\n    hoverOffset\n  );\n\n  // Generate the static hitbox path (always uses base outer radius)\n  const hitboxPath = generateArcPath(\n    innerRadius,\n    outerRadius,\n    arcData.startAngle,\n    arcData.endAngle,\n    cornerRadius,\n    arcData.padAngle\n  );\n\n  // Generate the visible path for grow effect\n  const grownOuterRadius = isHovered ? outerRadius + hoverOffset : outerRadius;\n  const grownPath = generateArcPath(\n    innerRadius,\n    grownOuterRadius,\n    arcData.startAngle,\n    arcData.endAngle,\n    cornerRadius,\n    arcData.padAngle\n  );\n\n  // Render animated slice based on effect type\n  const renderAnimatedSlice = () => {\n    if (hoverEffect === \"grow\") {\n      return (\n        <AnimatedSliceGrow\n          animationKey={animationKey}\n          color={color}\n          cornerRadius={cornerRadius}\n          endAngle={arcData.endAngle}\n          fill={fill}\n          hoverOffset={hoverOffset}\n          index={index}\n          innerRadius={innerRadius}\n          isFaded={isFaded}\n          isHovered={isHovered}\n          outerRadius={outerRadius}\n          padAngle={arcData.padAngle}\n          showGlow={showGlow}\n          startAngle={arcData.startAngle}\n        />\n      );\n    }\n\n    // Default: translate effect (also covers \"none\" with hoverOffset=0)\n    return (\n      <AnimatedSliceTranslate\n        animationKey={animationKey}\n        color={color}\n        cornerRadius={cornerRadius}\n        endAngle={arcData.endAngle}\n        fill={fill}\n        hoverOffset={hoverEffect === \"none\" ? 0 : hoverOffset}\n        index={index}\n        innerRadius={innerRadius}\n        isFaded={isFaded}\n        isHovered={isHovered}\n        outerRadius={outerRadius}\n        padAngle={arcData.padAngle}\n        showGlow={showGlow}\n        startAngle={arcData.startAngle}\n      />\n    );\n  };\n\n  // Render static (non-animated) slice\n  const renderStaticSlice = () => {\n    if (hoverEffect === \"grow\") {\n      return (\n        <motion.path\n          animate={{\n            opacity: isFaded ? 0.4 : 1,\n            d: grownPath,\n          }}\n          d={hitboxPath}\n          fill={fill}\n          pointerEvents=\"none\"\n          style={{\n            filter:\n              showGlow && isHovered ? `drop-shadow(0 0 12px ${color})` : \"none\",\n          }}\n          transition={{\n            opacity: { duration: 0.15 },\n            d: { type: \"spring\", stiffness: 400, damping: 25 },\n          }}\n        />\n      );\n    }\n\n    // Default: translate effect\n    const shouldTranslate = hoverEffect !== \"none\" && isHovered;\n    const translateX = shouldTranslate ? offset.x : 0;\n    const translateY = shouldTranslate ? offset.y : 0;\n\n    return (\n      <motion.path\n        animate={{\n          opacity: isFaded ? 0.4 : 1,\n          x: translateX,\n          y: translateY,\n        }}\n        d={hitboxPath}\n        fill={fill}\n        pointerEvents=\"none\"\n        style={{\n          filter:\n            showGlow && isHovered ? `drop-shadow(0 0 12px ${color})` : \"none\",\n        }}\n        transition={{\n          opacity: { duration: 0.15 },\n          x: { type: \"spring\", stiffness: 400, damping: 25 },\n          y: { type: \"spring\", stiffness: 400, damping: 25 },\n        }}\n      />\n    );\n  };\n\n  return (\n    <g style={{ cursor: \"pointer\" }}>\n      {/* Invisible hitbox - stays in place, handles hover events */}\n      {/* biome-ignore lint/a11y/noStaticElementInteractions: SVG path used as hover hitbox for visualization */}\n      <path\n        d={hitboxPath}\n        fill=\"transparent\"\n        onMouseEnter={() => setHoveredIndex(index)}\n        onMouseLeave={() => setHoveredIndex(null)}\n      />\n\n      {/* Visible slice - animates based on hover effect, no pointer events */}\n      {animate ? renderAnimatedSlice() : renderStaticSlice()}\n    </g>\n  );\n}\n\nPieSlice.displayName = \"PieSlice\";\n\nexport default PieSlice;\n",
      "type": "registry:component",
      "target": "components/charts/pie-slice.tsx"
    },
    {
      "path": "src/charts/pie-center.tsx",
      "content": "\"use client\";\n\nimport NumberFlow from \"@number-flow/react\";\nimport type { ReactNode } from \"react\";\nimport { cn } from \"../lib/utils\";\nimport { usePie } from \"./pie-context\";\n\n// NumberFlow format - subset of Intl.NumberFormatOptions\ninterface NumberFlowFormat {\n  notation?: \"standard\" | \"compact\";\n  compactDisplay?: \"short\" | \"long\";\n  minimumFractionDigits?: number;\n  maximumFractionDigits?: number;\n  minimumIntegerDigits?: number;\n  minimumSignificantDigits?: number;\n  maximumSignificantDigits?: number;\n  style?: \"decimal\" | \"percent\" | \"currency\";\n  currency?: string;\n  currencyDisplay?: \"symbol\" | \"narrowSymbol\" | \"code\" | \"name\";\n  unit?: string;\n  unitDisplay?: \"short\" | \"long\" | \"narrow\";\n}\n\nexport interface PieCenterProps {\n  /** Label shown below the value. Default: \"Total\" when not hovering */\n  defaultLabel?: string;\n  /** Format options for NumberFlow. Default: standard notation */\n  formatOptions?: NumberFlowFormat;\n  /** Custom render function for complete control over center content */\n  children?: (props: {\n    value: number;\n    label: string;\n    isHovered: boolean;\n    data: { label: string; value: number; color?: string; fill?: string };\n  }) => ReactNode;\n  /** Additional class name for the container */\n  className?: string;\n  /** Class name for the value text. Default: \"text-2xl font-bold\" */\n  valueClassName?: string;\n  /** Class name for the label text. Default: \"text-xs\" */\n  labelClassName?: string;\n  /** Prefix to show before the number (e.g., \"$\") */\n  prefix?: string;\n  /** Suffix to show after the number (e.g., \"%\") */\n  suffix?: string;\n}\n\n// Default format options\nconst defaultFormatOptions: NumberFlowFormat = {\n  notation: \"standard\",\n  maximumFractionDigits: 0,\n};\n\n/**\n * PieCenter displays content in the center of a donut/pie chart.\n *\n * This component renders as pure HTML (not inside SVG foreignObject) to avoid\n * Safari's WebKit bug #23113 where HTML content with CSS transforms/opacity\n * inside foreignObject renders at incorrect positions.\n *\n * The parent PieChart uses CSS Grid stacking to overlay this HTML content\n * on top of the SVG slices.\n */\nexport function PieCenter({\n  defaultLabel = \"Total\",\n  formatOptions = defaultFormatOptions,\n  children,\n  className = \"\",\n  valueClassName = \"text-2xl font-bold\",\n  labelClassName = \"text-xs\",\n  prefix,\n  suffix,\n}: PieCenterProps) {\n  const { data, hoveredIndex, totalValue, innerRadius } = usePie();\n\n  const hoveredData = hoveredIndex !== null ? data[hoveredIndex] : null;\n  const displayValue = hoveredData ? hoveredData.value : totalValue;\n  const displayLabel = hoveredData ? hoveredData.label : defaultLabel;\n  const isHovered = hoveredIndex !== null;\n\n  // Calculate center area size based on inner radius\n  // Leave some padding so text doesn't touch the inner edge\n  const centerSize = innerRadius * 2 - 16;\n\n  // Don't render if there's no inner radius (solid pie, not donut)\n  if (innerRadius <= 0) {\n    return null;\n  }\n\n  // If custom render function is provided, use it\n  if (children && hoveredData) {\n    return (\n      <div\n        className={cn(\"flex items-center justify-center\", className)}\n        style={{ width: centerSize, height: centerSize }}\n      >\n        {children({\n          value: displayValue,\n          label: displayLabel,\n          isHovered,\n          data: hoveredData,\n        })}\n      </div>\n    );\n  }\n\n  // Default center content with NumberFlow animations\n  // Now renders as pure HTML, avoiding Safari's foreignObject bugs\n  return (\n    <div\n      className={cn(\n        \"flex flex-col items-center justify-center text-center\",\n        className\n      )}\n      style={{ width: centerSize, height: centerSize }}\n    >\n      <span className={cn(\"text-foreground tabular-nums\", valueClassName)}>\n        <NumberFlow\n          format={formatOptions}\n          prefix={prefix}\n          suffix={suffix}\n          value={displayValue}\n          willChange\n        />\n      </span>\n      <span className={cn(\"mt-0.5 text-chart-label\", labelClassName)}>\n        {displayLabel}\n      </span>\n    </div>\n  );\n}\n\nPieCenter.displayName = \"PieCenter\";\n\nexport default PieCenter;\n",
      "type": "registry:component",
      "target": "components/charts/pie-center.tsx"
    }
  ]
}