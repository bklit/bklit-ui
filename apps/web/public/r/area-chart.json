{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "area-chart",
  "type": "registry:component",
  "title": "Area Chart",
  "description": "A composable area chart with gradient fills and animations",
  "dependencies": [
    "@visx/curve@4.0.1-alpha.0",
    "@visx/gradient@4.0.1-alpha.0",
    "@visx/shape@4.0.1-alpha.0",
    "motion"
  ],
  "registryDependencies": [
    "https://ui.bklit.com/r/chart-context.json",
    "https://ui.bklit.com/r/grid.json",
    "https://ui.bklit.com/r/x-axis.json",
    "https://ui.bklit.com/r/chart-tooltip.json",
    "https://ui.bklit.com/r/utils.json"
  ],
  "files": [
    {
      "path": "src/charts/area-chart.tsx",
      "content": "\"use client\";\n\nimport { ParentSize } from \"@visx/responsive\";\nimport { scaleLinear, scaleTime } from \"@visx/scale\";\nimport { bisector } from \"d3-array\";\nimport {\n  Children,\n  isValidElement,\n  type ReactElement,\n  type ReactNode,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport { cn } from \"../lib/utils\";\nimport { Area, type AreaProps } from \"./area\";\nimport { ChartProvider, type LineConfig, type Margin } from \"./chart-context\";\nimport { useChartInteraction } from \"./use-chart-interaction\";\n\n// Check if a component should render after the mouse overlay (markers need to be on top for interaction)\nfunction isPostOverlayComponent(child: ReactElement): boolean {\n  const childType = child.type as {\n    displayName?: string;\n    name?: string;\n    __isChartMarkers?: boolean;\n  };\n\n  // Check for static marker property (more reliable than displayName)\n  if (childType.__isChartMarkers) {\n    return true;\n  }\n\n  // Fallback to displayName check\n  const componentName =\n    typeof child.type === \"function\"\n      ? childType.displayName || childType.name || \"\"\n      : \"\";\n\n  return componentName === \"ChartMarkers\" || componentName === \"MarkerGroup\";\n}\n\nexport interface AreaChartProps {\n  /** Data array - each item should have a date field and numeric values */\n  data: Record<string, unknown>[];\n  /** Key in data for the x-axis (date). Default: \"date\" */\n  xDataKey?: string;\n  /** Chart margins */\n  margin?: Partial<Margin>;\n  /** Animation duration in milliseconds. Default: 1100 */\n  animationDuration?: number;\n  /** Aspect ratio as \"width / height\". Default: \"2 / 1\" */\n  aspectRatio?: string;\n  /** Additional class name for the container */\n  className?: string;\n  /** Child components (Area, Grid, ChartTooltip, etc.) */\n  children: ReactNode;\n}\n\nconst DEFAULT_MARGIN: Margin = { top: 40, right: 40, bottom: 40, left: 40 };\n\n// Extract area/line configs from children synchronously to avoid render timing issues\nfunction extractAreaConfigs(children: ReactNode): LineConfig[] {\n  const configs: LineConfig[] = [];\n\n  Children.forEach(children, (child) => {\n    if (!isValidElement(child)) {\n      return;\n    }\n\n    // Check if it's an Area component by displayName, function reference, or props structure\n    const childType = child.type as {\n      displayName?: string;\n      name?: string;\n    };\n    const componentName =\n      typeof child.type === \"function\"\n        ? childType.displayName || childType.name || \"\"\n        : \"\";\n\n    // Check by displayName, or by props having dataKey (duck typing)\n    const props = child.props as AreaProps | undefined;\n    const isAreaComponent =\n      componentName === \"Area\" ||\n      child.type === Area ||\n      (props && typeof props.dataKey === \"string\" && props.dataKey.length > 0);\n\n    if (isAreaComponent && props?.dataKey) {\n      configs.push({\n        dataKey: props.dataKey,\n        stroke: props.stroke || props.fill || \"var(--chart-line-primary)\",\n        strokeWidth: props.strokeWidth || 2,\n      });\n    }\n  });\n\n  return configs;\n}\n\ninterface ChartInnerProps {\n  width: number;\n  height: number;\n  data: Record<string, unknown>[];\n  xDataKey: string;\n  margin: Margin;\n  animationDuration: number;\n  children: ReactNode;\n  containerRef: React.RefObject<HTMLDivElement | null>;\n}\n\nfunction ChartInner({\n  width,\n  height,\n  data,\n  xDataKey,\n  margin,\n  animationDuration,\n  children,\n  containerRef,\n}: ChartInnerProps) {\n  const [isLoaded, setIsLoaded] = useState(false);\n\n  // Extract area configs synchronously from children\n  const lines = useMemo(() => extractAreaConfigs(children), [children]);\n\n  const innerWidth = width - margin.left - margin.right;\n  const innerHeight = height - margin.top - margin.bottom;\n\n  // X accessor function\n  const xAccessor = useCallback(\n    (d: Record<string, unknown>): Date => {\n      const value = d[xDataKey];\n      return value instanceof Date ? value : new Date(value as string | number);\n    },\n    [xDataKey]\n  );\n\n  // Create bisector for finding nearest data point\n  const bisectDate = useMemo(\n    () => bisector<Record<string, unknown>, Date>((d) => xAccessor(d)).left,\n    [xAccessor]\n  );\n\n  // X scale (time) - use exact data domain for tight fit\n  const xScale = useMemo(() => {\n    const dates = data.map((d) => xAccessor(d));\n    const minTime = Math.min(...dates.map((d) => d.getTime()));\n    const maxTime = Math.max(...dates.map((d) => d.getTime()));\n\n    return scaleTime({\n      range: [0, innerWidth],\n      domain: [minTime, maxTime],\n    });\n  }, [innerWidth, data, xAccessor]);\n\n  // Calculate column width (spacing between data points)\n  const columnWidth = useMemo(() => {\n    if (data.length < 2) {\n      return 0;\n    }\n    return innerWidth / (data.length - 1);\n  }, [innerWidth, data.length]);\n\n  // Y scale - computed from extracted area configs (available immediately)\n  const yScale = useMemo(() => {\n    let maxValue = 0;\n    for (const line of lines) {\n      for (const d of data) {\n        const value = d[line.dataKey];\n        if (typeof value === \"number\" && value > maxValue) {\n          maxValue = value;\n        }\n      }\n    }\n\n    if (maxValue === 0) {\n      maxValue = 100;\n    }\n\n    return scaleLinear({\n      range: [innerHeight, 0],\n      domain: [0, maxValue * 1.1],\n      nice: true,\n    });\n  }, [innerHeight, data, lines]);\n\n  // Pre-compute date labels for ticker animation\n  const dateLabels = useMemo(\n    () =>\n      data.map((d) =>\n        xAccessor(d).toLocaleDateString(\"en-US\", {\n          month: \"short\",\n          day: \"numeric\",\n        })\n      ),\n    [data, xAccessor]\n  );\n\n  // Animation timing\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setIsLoaded(true);\n    }, animationDuration);\n    return () => clearTimeout(timer);\n  }, [animationDuration]);\n\n  const canInteract = isLoaded;\n\n  const {\n    tooltipData,\n    setTooltipData,\n    selection,\n    clearSelection,\n    interactionHandlers,\n    interactionStyle,\n  } = useChartInteraction({\n    xScale,\n    yScale,\n    data,\n    lines,\n    margin,\n    xAccessor,\n    bisectDate,\n    canInteract,\n  });\n\n  // Early return if dimensions not ready\n  if (width < 10 || height < 10) {\n    return null;\n  }\n\n  // Separate children into pre-overlay (Grid, Area) and post-overlay (ChartMarkers)\n  const preOverlayChildren: ReactElement[] = [];\n  const postOverlayChildren: ReactElement[] = [];\n\n  Children.forEach(children, (child) => {\n    if (!isValidElement(child)) {\n      return;\n    }\n\n    if (isPostOverlayComponent(child)) {\n      postOverlayChildren.push(child);\n    } else {\n      preOverlayChildren.push(child);\n    }\n  });\n\n  const contextValue = {\n    data,\n    xScale,\n    yScale,\n    width,\n    height,\n    innerWidth,\n    innerHeight,\n    margin,\n    columnWidth,\n    tooltipData,\n    setTooltipData,\n    containerRef,\n    lines,\n    isLoaded,\n    animationDuration,\n    xAccessor,\n    dateLabels,\n    selection,\n    clearSelection,\n  };\n\n  return (\n    <ChartProvider value={contextValue}>\n      <svg aria-hidden=\"true\" height={height} width={width}>\n        <defs>\n          <clipPath id=\"chart-area-grow-clip\">\n            <rect\n              height={innerHeight + 20}\n              style={{\n                transition: isLoaded\n                  ? \"none\"\n                  : `width ${animationDuration}ms cubic-bezier(0.85, 0, 0.15, 1)`,\n              }}\n              width={isLoaded ? innerWidth : 0}\n              x={0}\n              y={0}\n            />\n          </clipPath>\n        </defs>\n\n        <rect fill=\"transparent\" height={height} width={width} x={0} y={0} />\n\n        <g\n          {...interactionHandlers}\n          style={interactionStyle}\n          transform={`translate(${margin.left},${margin.top})`}\n        >\n          <rect\n            fill=\"transparent\"\n            height={innerHeight}\n            width={innerWidth}\n            x={0}\n            y={0}\n          />\n\n          {preOverlayChildren}\n          {postOverlayChildren}\n        </g>\n      </svg>\n    </ChartProvider>\n  );\n}\n\nexport function AreaChart({\n  data,\n  xDataKey = \"date\",\n  margin: marginProp,\n  animationDuration = 1100,\n  aspectRatio = \"2 / 1\",\n  className = \"\",\n  children,\n}: AreaChartProps) {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const margin = { ...DEFAULT_MARGIN, ...marginProp };\n\n  return (\n    <div\n      className={cn(\"relative w-full\", className)}\n      ref={containerRef}\n      style={{ aspectRatio, touchAction: \"none\" }}\n    >\n      <ParentSize debounceTime={10}>\n        {({ width, height }) => (\n          <ChartInner\n            animationDuration={animationDuration}\n            containerRef={containerRef}\n            data={data}\n            height={height}\n            margin={margin}\n            width={width}\n            xDataKey={xDataKey}\n          >\n            {children}\n          </ChartInner>\n        )}\n      </ParentSize>\n    </div>\n  );\n}\n\n// Re-export Area for convenience\nexport { Area, type AreaProps } from \"./area\";\n\nexport default AreaChart;\n",
      "type": "registry:component",
      "target": "components/charts/area-chart.tsx"
    },
    {
      "path": "src/charts/area.tsx",
      "content": "\"use client\";\n\nimport { curveMonotoneX } from \"@visx/curve\";\nimport { AreaClosed, LinePath } from \"@visx/shape\";\n\n// CurveFactory type - simplified version compatible with visx\n// biome-ignore lint/suspicious/noExplicitAny: d3 curve factory type\ntype CurveFactory = any;\n\nimport { motion, useMotionTemplate, useSpring } from \"motion/react\";\nimport {\n  useCallback,\n  useEffect,\n  useId,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport { chartCssVars, useChart } from \"./chart-context\";\n\nexport interface AreaProps {\n  /** Key in data to use for y values */\n  dataKey: string;\n  /** Fill color for the area gradient start. Default: var(--chart-line-primary) */\n  fill?: string;\n  /** Fill opacity at the top of the area. Default: 0.4 */\n  fillOpacity?: number;\n  /** Stroke color for the line. Default: same as fill */\n  stroke?: string;\n  /** Stroke width. Default: 2 */\n  strokeWidth?: number;\n  /** Curve function. Default: curveMonotoneX */\n  curve?: CurveFactory;\n  /** Whether to animate the area. Default: true */\n  animate?: boolean;\n  /** Whether to show the stroke line. Default: true */\n  showLine?: boolean;\n  /** Whether to show highlight segment on hover. Default: true */\n  showHighlight?: boolean;\n  /** Gradient opacity at bottom (0 = fully transparent). Default: 0 */\n  gradientToOpacity?: number;\n  /** Whether to fade the area fill at left/right edges. Default: false */\n  fadeEdges?: boolean;\n}\n\nexport function Area({\n  dataKey,\n  fill = chartCssVars.linePrimary,\n  fillOpacity = 0.4,\n  stroke,\n  strokeWidth = 2,\n  curve = curveMonotoneX,\n  animate = true,\n  showLine = true,\n  showHighlight = true,\n  gradientToOpacity = 0,\n  fadeEdges = false,\n}: AreaProps) {\n  const {\n    data,\n    xScale,\n    yScale,\n    innerHeight,\n    innerWidth,\n    tooltipData,\n    selection,\n    isLoaded,\n    animationDuration,\n    xAccessor,\n  } = useChart();\n\n  const pathRef = useRef<SVGPathElement>(null);\n  const [pathLength, setPathLength] = useState(0);\n  const [clipWidth, setClipWidth] = useState(0);\n\n  // Unique IDs for this area\n  const uniqueId = useId();\n  const gradientId = useMemo(\n    () => `area-gradient-${dataKey}-${Math.random().toString(36).slice(2, 9)}`,\n    [dataKey]\n  );\n  const strokeGradientId = useMemo(\n    () =>\n      `area-stroke-gradient-${dataKey}-${Math.random().toString(36).slice(2, 9)}`,\n    [dataKey]\n  );\n  const edgeMaskId = `area-edge-mask-${dataKey}-${uniqueId}`;\n  const edgeGradientId = `${edgeMaskId}-gradient`;\n\n  // Resolved stroke color (defaults to fill)\n  const resolvedStroke = stroke || fill;\n\n  // Measure path length and trigger animation\n  useEffect(() => {\n    if (pathRef.current && animate) {\n      const len = pathRef.current.getTotalLength();\n      if (len > 0) {\n        setPathLength(len);\n        if (!isLoaded) {\n          requestAnimationFrame(() => {\n            setClipWidth(innerWidth);\n          });\n        }\n      }\n    }\n  }, [animate, innerWidth, isLoaded]);\n\n  // Binary search to find path length at a given X coordinate\n  const findLengthAtX = useCallback(\n    (targetX: number): number => {\n      const path = pathRef.current;\n      if (!path || pathLength === 0) {\n        return 0;\n      }\n      let low = 0;\n      let high = pathLength;\n      const tolerance = 0.5;\n\n      while (high - low > tolerance) {\n        const mid = (low + high) / 2;\n        const point = path.getPointAtLength(mid);\n        if (point.x < targetX) {\n          low = mid;\n        } else {\n          high = mid;\n        }\n      }\n      return (low + high) / 2;\n    },\n    [pathLength]\n  );\n\n  // Calculate segment bounds for highlight from either selection or hover\n  const segmentBounds = useMemo(() => {\n    if (!pathRef.current || pathLength === 0) {\n      return { startLength: 0, segmentLength: 0, isActive: false };\n    }\n\n    // Selection takes priority over hover\n    if (selection?.active) {\n      const startLength = findLengthAtX(selection.startX);\n      const endLength = findLengthAtX(selection.endX);\n      return {\n        startLength,\n        segmentLength: endLength - startLength,\n        isActive: true,\n      };\n    }\n\n    if (!tooltipData) {\n      return { startLength: 0, segmentLength: 0, isActive: false };\n    }\n\n    const idx = tooltipData.index;\n    const startIdx = Math.max(0, idx - 1);\n    const endIdx = Math.min(data.length - 1, idx + 1);\n\n    const startPoint = data[startIdx];\n    const endPoint = data[endIdx];\n    if (!(startPoint && endPoint)) {\n      return { startLength: 0, segmentLength: 0, isActive: false };\n    }\n\n    const startX = xScale(xAccessor(startPoint)) ?? 0;\n    const endX = xScale(xAccessor(endPoint)) ?? 0;\n\n    const startLength = findLengthAtX(startX);\n    const endLength = findLengthAtX(endX);\n\n    return {\n      startLength,\n      segmentLength: endLength - startLength,\n      isActive: true,\n    };\n  }, [\n    tooltipData,\n    selection,\n    data,\n    xScale,\n    pathLength,\n    xAccessor,\n    findLengthAtX,\n  ]);\n\n  // Springs for smooth highlight animation (both offset AND segment length)\n  const springConfig = { stiffness: 180, damping: 28 };\n  const offsetSpring = useSpring(0, springConfig);\n  const segmentLengthSpring = useSpring(0, springConfig);\n\n  // Create animated strokeDasharray using motion template\n  const animatedDasharray = useMotionTemplate`${segmentLengthSpring} ${pathLength}`;\n\n  // Update springs when segment bounds change\n  useEffect(() => {\n    offsetSpring.set(-segmentBounds.startLength);\n    segmentLengthSpring.set(segmentBounds.segmentLength);\n  }, [\n    segmentBounds.startLength,\n    segmentBounds.segmentLength,\n    offsetSpring,\n    segmentLengthSpring,\n  ]);\n\n  // Get y value for a data point\n  const getY = useCallback(\n    (d: Record<string, unknown>) => {\n      const value = d[dataKey];\n      return typeof value === \"number\" ? (yScale(value) ?? 0) : 0;\n    },\n    [dataKey, yScale]\n  );\n\n  const isHovering = tooltipData !== null || selection?.active === true;\n  const easing = \"cubic-bezier(0.85, 0, 0.15, 1)\";\n\n  return (\n    <>\n      {/* Gradient definitions */}\n      <defs>\n        {/* Fill gradient - fades from fillOpacity at top to gradientToOpacity at bottom */}\n        <linearGradient id={gradientId} x1=\"0%\" x2=\"0%\" y1=\"0%\" y2=\"100%\">\n          <stop\n            offset=\"0%\"\n            style={{ stopColor: fill, stopOpacity: fillOpacity }}\n          />\n          <stop\n            offset=\"100%\"\n            style={{ stopColor: fill, stopOpacity: gradientToOpacity }}\n          />\n        </linearGradient>\n\n        {/* Stroke gradient - fades at edges */}\n        <linearGradient id={strokeGradientId} x1=\"0%\" x2=\"100%\" y1=\"0%\" y2=\"0%\">\n          <stop\n            offset=\"0%\"\n            style={{ stopColor: resolvedStroke, stopOpacity: 0 }}\n          />\n          <stop\n            offset=\"15%\"\n            style={{ stopColor: resolvedStroke, stopOpacity: 1 }}\n          />\n          <stop\n            offset=\"85%\"\n            style={{ stopColor: resolvedStroke, stopOpacity: 1 }}\n          />\n          <stop\n            offset=\"100%\"\n            style={{ stopColor: resolvedStroke, stopOpacity: 0 }}\n          />\n        </linearGradient>\n\n        {/* Edge fade mask for area fill */}\n        {fadeEdges && (\n          <>\n            <linearGradient\n              id={edgeGradientId}\n              x1=\"0%\"\n              x2=\"100%\"\n              y1=\"0%\"\n              y2=\"0%\"\n            >\n              <stop\n                offset=\"0%\"\n                style={{ stopColor: \"white\", stopOpacity: 0 }}\n              />\n              <stop\n                offset=\"20%\"\n                style={{ stopColor: \"white\", stopOpacity: 1 }}\n              />\n              <stop\n                offset=\"80%\"\n                style={{ stopColor: \"white\", stopOpacity: 1 }}\n              />\n              <stop\n                offset=\"100%\"\n                style={{ stopColor: \"white\", stopOpacity: 0 }}\n              />\n            </linearGradient>\n            <mask id={edgeMaskId}>\n              <rect\n                fill={`url(#${edgeGradientId})`}\n                height={innerHeight}\n                width={innerWidth}\n                x=\"0\"\n                y=\"0\"\n              />\n            </mask>\n          </>\n        )}\n      </defs>\n\n      {/* Clip path for grow animation - unique per area */}\n      {animate && (\n        <defs>\n          <clipPath id={`grow-clip-area-${dataKey}`}>\n            <rect\n              height={innerHeight + 20}\n              style={{\n                transition:\n                  !isLoaded && clipWidth > 0\n                    ? `width ${animationDuration}ms ${easing}`\n                    : \"none\",\n              }}\n              width={isLoaded ? innerWidth : clipWidth}\n              x={0}\n              y={0}\n            />\n          </clipPath>\n        </defs>\n      )}\n\n      {/* Main area with clip path */}\n      <g clipPath={animate ? `url(#grow-clip-area-${dataKey})` : undefined}>\n        <motion.g\n          animate={{ opacity: isHovering && showHighlight ? 0.6 : 1 }}\n          initial={{ opacity: 1 }}\n          transition={{ duration: 0.4, ease: \"easeInOut\" }}\n        >\n          {/* Area fill */}\n          <g mask={fadeEdges ? `url(#${edgeMaskId})` : undefined}>\n            <AreaClosed\n              curve={curve}\n              data={data}\n              fill={`url(#${gradientId})`}\n              x={(d) => xScale(xAccessor(d)) ?? 0}\n              y={getY}\n              yScale={yScale}\n            />\n          </g>\n\n          {/* Stroke line on top of area */}\n          {showLine && (\n            <LinePath\n              curve={curve}\n              data={data}\n              innerRef={pathRef}\n              stroke={`url(#${strokeGradientId})`}\n              strokeLinecap=\"round\"\n              strokeWidth={strokeWidth}\n              x={(d) => xScale(xAccessor(d)) ?? 0}\n              y={getY}\n            />\n          )}\n        </motion.g>\n      </g>\n\n      {/* Highlight segment on hover */}\n      {showHighlight &&\n        showLine &&\n        isHovering &&\n        isLoaded &&\n        pathRef.current && (\n          <motion.path\n            animate={{ opacity: 1 }}\n            d={pathRef.current.getAttribute(\"d\") || \"\"}\n            exit={{ opacity: 0 }}\n            fill=\"none\"\n            initial={{ opacity: 0 }}\n            stroke={resolvedStroke}\n            strokeLinecap=\"round\"\n            strokeWidth={strokeWidth}\n            style={{\n              strokeDasharray: animatedDasharray,\n              strokeDashoffset: offsetSpring,\n            }}\n            transition={{ duration: 0.4, ease: \"easeInOut\" }}\n          />\n        )}\n    </>\n  );\n}\n\nArea.displayName = \"Area\";\n\nexport default Area;\n",
      "type": "registry:component",
      "target": "components/charts/area.tsx"
    }
  ]
}
