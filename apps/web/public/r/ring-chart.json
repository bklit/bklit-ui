{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "ring-chart",
  "type": "registry:component",
  "title": "Ring Chart",
  "description": "A composable donut/ring chart with progress indicators",
  "dependencies": ["@visx/responsive", "@number-flow/react", "motion"],
  "registryDependencies": ["https://ui.bklit.com/r/utils.json"],
  "files": [
    {
      "path": "src/charts/ring-chart.tsx",
      "content": "\"use client\";\n\nimport { Group } from \"@visx/group\";\nimport { ParentSize } from \"@visx/responsive\";\nimport {\n  Children,\n  isValidElement,\n  type ReactNode,\n  useCallback,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport { cn } from \"../lib/utils\";\nimport {\n  defaultRingColors,\n  type RingContextValue,\n  type RingData,\n  RingProvider,\n} from \"./ring-context\";\n\nexport interface RingChartProps {\n  /** Data array - each item represents a ring */\n  data: RingData[];\n  /** Chart size in pixels. If not provided, uses parent container size */\n  size?: number;\n  /** Stroke width of each ring. Default: 12 */\n  strokeWidth?: number;\n  /** Gap between rings. Default: 6 */\n  ringGap?: number;\n  /** Inner radius of the innermost ring. Default: 60 */\n  baseInnerRadius?: number;\n  /** Animation duration in milliseconds. Default: 1100 */\n  animationDuration?: number;\n  /** Additional class name for the container */\n  className?: string;\n  /** Controlled hover state - index of hovered ring */\n  hoveredIndex?: number | null;\n  /** Callback when hover state changes */\n  onHoverChange?: (index: number | null) => void;\n  /** Child components (Ring, RingCenter, etc.) */\n  children: ReactNode;\n}\n\ninterface RingChartInnerProps {\n  width: number;\n  height: number;\n  data: RingData[];\n  strokeWidth: number;\n  ringGap: number;\n  baseInnerRadius: number;\n  children: ReactNode;\n  containerRef: React.RefObject<HTMLDivElement | null>;\n  hoveredIndexProp?: number | null;\n  onHoverChange?: (index: number | null) => void;\n}\n\n// Helper to check if a child is a RingCenter component\nfunction isRingCenter(child: ReactNode): boolean {\n  return (\n    isValidElement(child) &&\n    typeof child.type === \"function\" &&\n    ((child.type as { displayName?: string }).displayName === \"RingCenter\" ||\n      child.type.name === \"RingCenter\")\n  );\n}\n\nfunction RingChartInner({\n  width,\n  height,\n  data,\n  strokeWidth: strokeWidthProp,\n  ringGap: ringGapProp,\n  baseInnerRadius: baseInnerRadiusProp,\n  children,\n  containerRef,\n  hoveredIndexProp,\n  onHoverChange,\n}: RingChartInnerProps) {\n  const [internalHoveredIndex, setInternalHoveredIndex] = useState<\n    number | null\n  >(null);\n  const [animationKey] = useState(0);\n  const [isLoaded, setIsLoaded] = useState(false);\n\n  // Use controlled or uncontrolled hover state\n  const isControlled = hoveredIndexProp !== undefined;\n  const hoveredIndex = isControlled ? hoveredIndexProp : internalHoveredIndex;\n  const setHoveredIndex = useCallback(\n    (index: number | null) => {\n      if (isControlled) {\n        onHoverChange?.(index);\n      } else {\n        setInternalHoveredIndex(index);\n      }\n    },\n    [isControlled, onHoverChange]\n  );\n\n  // Use the smaller dimension to ensure the chart fits\n  const size = Math.min(width, height);\n  const center = size / 2;\n\n  // Calculate scaled dimensions to fit within the available space\n  // The outermost ring needs to fit within the chart with some padding\n  const ringCount = data.length;\n  const padding = 8; // Padding from edge\n  const availableRadius = center - padding;\n\n  // Calculate the \"design\" outer radius (what we'd need at 1:1 scale)\n  const designOuterRadius =\n    baseInnerRadiusProp +\n    (ringCount - 1) * (strokeWidthProp + ringGapProp) +\n    strokeWidthProp;\n\n  // Scale factor to fit within available space\n  const scale = Math.min(1, availableRadius / designOuterRadius);\n\n  // Apply scaling to all dimensions\n  const strokeWidth = strokeWidthProp * scale;\n  const ringGap = ringGapProp * scale;\n  const baseInnerRadius = baseInnerRadiusProp * scale;\n\n  // Calculate total value\n  const totalValue = useMemo(\n    () => data.reduce((sum, d) => sum + d.value, 0),\n    [data]\n  );\n\n  // Get color for a ring index\n  const getColor = useCallback(\n    (index: number) => {\n      const item = data[index];\n      if (item?.color) {\n        return item.color;\n      }\n      return defaultRingColors[index % defaultRingColors.length] as string;\n    },\n    [data]\n  );\n\n  // Get ring radii for an index\n  const getRingRadii = useCallback(\n    (index: number) => {\n      const innerRadius = baseInnerRadius + index * (strokeWidth + ringGap);\n      const outerRadius = innerRadius + strokeWidth;\n      return { innerRadius, outerRadius };\n    },\n    [baseInnerRadius, strokeWidth, ringGap]\n  );\n\n  // Mark as loaded after initial render\n  useState(() => {\n    const timer = setTimeout(() => {\n      setIsLoaded(true);\n    }, 100);\n    return () => clearTimeout(timer);\n  });\n\n  // Separate SVG children (rings) from HTML children (RingCenter)\n  // This avoids Safari's foreignObject positioning bugs (WebKit #23113)\n  const { svgChildren, centerChildren } = useMemo(() => {\n    const svgNodes: ReactNode[] = [];\n    const centerNodes: ReactNode[] = [];\n\n    Children.forEach(children, (child) => {\n      if (isRingCenter(child)) {\n        centerNodes.push(child);\n      } else {\n        svgNodes.push(child);\n      }\n    });\n\n    return { svgChildren: svgNodes, centerChildren: centerNodes };\n  }, [children]);\n\n  // Early return if dimensions not ready\n  if (size < 10) {\n    return null;\n  }\n\n  const contextValue: RingContextValue = {\n    data,\n    size,\n    center,\n    strokeWidth,\n    ringGap,\n    baseInnerRadius,\n    hoveredIndex,\n    setHoveredIndex,\n    animationKey,\n    isLoaded,\n    containerRef,\n    totalValue,\n    getColor,\n    getRingRadii,\n  };\n\n  // Use CSS Grid stacking to layer SVG and HTML content\n  // This avoids Safari's foreignObject rendering bugs where HTML content\n  // inside SVG foreignObject renders at wrong positions when it has a RenderLayer\n  return (\n    <RingProvider value={contextValue}>\n      <div\n        className=\"grid\"\n        style={{\n          gridTemplateColumns: \"1fr\",\n          gridTemplateRows: \"1fr\",\n          width: size,\n          height: size,\n        }}\n      >\n        {/* SVG layer with rings */}\n        <svg\n          aria-hidden=\"true\"\n          height={size}\n          style={{ gridArea: \"1 / 1\" }}\n          width={size}\n        >\n          <Group left={center} top={center}>\n            {svgChildren}\n          </Group>\n        </svg>\n\n        {/* HTML layer with center content - stacked on top via grid */}\n        {centerChildren.length > 0 && (\n          <div\n            className=\"pointer-events-none flex items-center justify-center\"\n            style={{ gridArea: \"1 / 1\" }}\n          >\n            {centerChildren}\n          </div>\n        )}\n      </div>\n    </RingProvider>\n  );\n}\n\nexport function RingChart({\n  data,\n  size: fixedSize,\n  strokeWidth = 12,\n  ringGap = 6,\n  baseInnerRadius = 60,\n  className = \"\",\n  hoveredIndex,\n  onHoverChange,\n  children,\n}: RingChartProps) {\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  // If fixed size is provided, use it directly\n  if (fixedSize) {\n    return (\n      <div\n        className={cn(\"relative flex items-center justify-center\", className)}\n        ref={containerRef}\n        style={{ width: fixedSize, height: fixedSize }}\n      >\n        <RingChartInner\n          baseInnerRadius={baseInnerRadius}\n          containerRef={containerRef}\n          data={data}\n          height={fixedSize}\n          hoveredIndexProp={hoveredIndex}\n          onHoverChange={onHoverChange}\n          ringGap={ringGap}\n          strokeWidth={strokeWidth}\n          width={fixedSize}\n        >\n          {children}\n        </RingChartInner>\n      </div>\n    );\n  }\n\n  // Otherwise use ParentSize for responsive sizing\n  return (\n    <div\n      className={cn(\"relative aspect-square w-full\", className)}\n      ref={containerRef}\n    >\n      <ParentSize debounceTime={10}>\n        {({ width, height }) => (\n          <RingChartInner\n            baseInnerRadius={baseInnerRadius}\n            containerRef={containerRef}\n            data={data}\n            height={height}\n            hoveredIndexProp={hoveredIndex}\n            onHoverChange={onHoverChange}\n            ringGap={ringGap}\n            strokeWidth={strokeWidth}\n            width={width}\n          >\n            {children}\n          </RingChartInner>\n        )}\n      </ParentSize>\n    </div>\n  );\n}\n\nexport default RingChart;\n",
      "type": "registry:component",
      "target": "components/charts/ring-chart.tsx"
    },
    {
      "path": "src/charts/ring-context.tsx",
      "content": "\"use client\";\n\nimport { createContext, type RefObject, useContext } from \"react\";\n\n// CSS variable references for ring chart theming\nexport const ringCssVars = {\n  background: \"var(--chart-background)\",\n  foreground: \"var(--chart-foreground)\",\n  foregroundMuted: \"var(--chart-foreground-muted)\",\n  label: \"var(--chart-label)\",\n  ringBackground: \"var(--chart-ring-background)\",\n  // Default ring colors from chart palette\n  ring1: \"var(--chart-1)\",\n  ring2: \"var(--chart-2)\",\n  ring3: \"var(--chart-3)\",\n  ring4: \"var(--chart-4)\",\n  ring5: \"var(--chart-5)\",\n};\n\n// Default ring color palette\nexport const defaultRingColors = [\n  ringCssVars.ring1,\n  ringCssVars.ring2,\n  ringCssVars.ring3,\n  ringCssVars.ring4,\n  ringCssVars.ring5,\n];\n\nexport interface RingData {\n  /** Display label for the ring */\n  label: string;\n  /** Current value */\n  value: number;\n  /** Maximum value (determines progress percentage) */\n  maxValue: number;\n  /** Optional color override - falls back to palette */\n  color?: string;\n}\n\nexport interface RingContextValue {\n  // Data\n  data: RingData[];\n\n  // Dimensions\n  size: number;\n  center: number;\n  strokeWidth: number;\n  ringGap: number;\n  baseInnerRadius: number;\n\n  // Hover state\n  hoveredIndex: number | null;\n  setHoveredIndex: (index: number | null) => void;\n\n  // Animation state\n  animationKey: number;\n  isLoaded: boolean;\n\n  // Container ref for portals\n  containerRef: RefObject<HTMLDivElement | null>;\n\n  // Computed values\n  totalValue: number;\n\n  // Get color for a ring index\n  getColor: (index: number) => string;\n\n  // Get ring radii for an index\n  getRingRadii: (index: number) => { innerRadius: number; outerRadius: number };\n}\n\nconst RingContext = createContext<RingContextValue | null>(null);\n\nexport function RingProvider({\n  children,\n  value,\n}: {\n  children: React.ReactNode;\n  value: RingContextValue;\n}) {\n  return <RingContext.Provider value={value}>{children}</RingContext.Provider>;\n}\n\nexport function useRing(): RingContextValue {\n  const context = useContext(RingContext);\n  if (!context) {\n    throw new Error(\n      \"useRing must be used within a RingProvider. \" +\n        \"Make sure your component is wrapped in <RingChart>.\"\n    );\n  }\n  return context;\n}\n\nexport default RingContext;\n",
      "type": "registry:component",
      "target": "components/charts/ring-context.tsx"
    },
    {
      "path": "src/charts/ring.tsx",
      "content": "\"use client\";\n\nimport { Arc, arc as arcGenerator } from \"@visx/shape\";\nimport { motion, useSpring, useTransform } from \"motion/react\";\nimport { useEffect, useRef } from \"react\";\nimport { ringCssVars, useRing } from \"./ring-context\";\n\n// Helper to generate arc path using d3 arc generator\nfunction generateArcPath(\n  innerRadius: number,\n  outerRadius: number,\n  startAngle: number,\n  endAngle: number,\n  cornerRadius: number\n): string {\n  const generator = arcGenerator<unknown>({\n    innerRadius,\n    outerRadius,\n    cornerRadius,\n  });\n  return generator({ startAngle, endAngle } as unknown as null) || \"\";\n}\n\nexport type RingLineCap = \"round\" | \"butt\";\n\nexport interface RingProps {\n  /** Index of the ring in the data array */\n  index: number;\n  /** Optional color override - falls back to data color or palette */\n  color?: string;\n  /** Animate the progress arc. Default: true */\n  animate?: boolean;\n  /** Show glow effect on hover. Default: true */\n  showGlow?: boolean;\n  /** Line cap style for ring ends. Default: \"round\" */\n  lineCap?: RingLineCap;\n}\n\ninterface AnimatedProgressArcProps {\n  index: number;\n  innerRadius: number;\n  outerRadius: number;\n  progress: number;\n  color: string;\n  isHovered: boolean;\n  isFaded: boolean;\n  isPushedOut: boolean;\n  animationKey: number;\n  showGlow: boolean;\n  lineCap: RingLineCap;\n}\n\nfunction AnimatedProgressArc({\n  index,\n  innerRadius,\n  outerRadius,\n  progress,\n  color,\n  isHovered,\n  isFaded,\n  isPushedOut,\n  animationKey,\n  showGlow,\n  lineCap,\n}: AnimatedProgressArcProps) {\n  const startAngle = -Math.PI / 2;\n  const targetEndAngle = startAngle + 2 * Math.PI * progress;\n  const cornerRadius =\n    lineCap === \"round\" ? (outerRadius - innerRadius) / 2 : 0;\n\n  // Progress arc delay - starts after background rings expand\n  const progressDelay = 0.6 + index * 0.1;\n\n  // Animate the end angle with spring\n  const springValue = useSpring(0, {\n    stiffness: 60,\n    damping: 20,\n    restDelta: 0.001,\n  });\n\n  // Reset and start animation on mount\n  useEffect(() => {\n    springValue.jump(0);\n    const timeout = setTimeout(() => {\n      springValue.set(1);\n    }, progressDelay * 1000);\n    return () => clearTimeout(timeout);\n  }, [progressDelay, springValue]);\n\n  // Transform spring value to arc path\n  const animatedPath = useTransform(springValue, (v) => {\n    const currentEndAngle = startAngle + (targetEndAngle - startAngle) * v;\n    if (currentEndAngle <= startAngle + 0.01) {\n      return \"\";\n    }\n    return generateArcPath(\n      innerRadius,\n      outerRadius,\n      startAngle,\n      currentEndAngle,\n      cornerRadius\n    );\n  });\n\n  // Calculate scale: hovered ring scales up, outer rings pushed out\n  const getScale = () => {\n    if (isHovered) {\n      return 1.03;\n    }\n    if (isPushedOut) {\n      return 1.02;\n    }\n    return 1;\n  };\n\n  return (\n    <motion.path\n      animate={{\n        opacity: isFaded ? 0.4 : 1,\n        scale: getScale(),\n      }}\n      d={animatedPath}\n      fill={color}\n      key={`progress-${animationKey}`}\n      style={{\n        transformOrigin: \"center\",\n        filter:\n          showGlow && isHovered ? `drop-shadow(0 0 12px ${color})` : \"none\",\n      }}\n      transition={{\n        opacity: { duration: 0.15 },\n        scale: { type: \"spring\", stiffness: 400, damping: 25 },\n      }}\n    />\n  );\n}\n\nexport function Ring({\n  index,\n  color: colorProp,\n  animate = true,\n  showGlow = true,\n  lineCap = \"round\",\n}: RingProps) {\n  const {\n    data,\n    hoveredIndex,\n    setHoveredIndex,\n    animationKey,\n    getColor,\n    getRingRadii,\n  } = useRing();\n\n  // Track if initial mount animation is complete (must be before early return)\n  const hasAnimated = useRef(false);\n  const ringExpandDelay = index * 0.08;\n\n  useEffect(() => {\n    if (animate && !hasAnimated.current) {\n      const timeout = setTimeout(\n        () => {\n          hasAnimated.current = true;\n        },\n        (ringExpandDelay + 0.3) * 1000\n      );\n      return () => clearTimeout(timeout);\n    }\n  }, [animate, ringExpandDelay]);\n\n  const ringData = data[index];\n  if (!ringData) {\n    return null;\n  }\n\n  const { innerRadius, outerRadius } = getRingRadii(index);\n  const color = colorProp || getColor(index);\n  const progress = ringData.value / ringData.maxValue;\n\n  const isHovered = hoveredIndex === index;\n  const isFaded = hoveredIndex !== null && hoveredIndex !== index;\n  // Ring is pushed out when a ring with lower index (inner ring) is hovered\n  const isPushedOut = hoveredIndex !== null && hoveredIndex < index;\n\n  // Only apply delay on initial mount, not on hover changes\n  const shouldDelay = animate && !hasAnimated.current;\n\n  // Calculate scale for background and progress arcs\n  const getScale = () => {\n    if (isHovered) {\n      return 1.03;\n    }\n    if (isPushedOut) {\n      return 1.02;\n    }\n    return 1;\n  };\n\n  return (\n    // biome-ignore lint/a11y/noStaticElementInteractions: SVG group for hover interaction\n    <g\n      onMouseEnter={() => setHoveredIndex(index)}\n      onMouseLeave={() => setHoveredIndex(null)}\n      style={{ cursor: \"pointer\" }}\n    >\n      {/* Background track - full circle */}\n      <Arc\n        cornerRadius={lineCap === \"round\" ? (outerRadius - innerRadius) / 2 : 0}\n        endAngle={2 * Math.PI}\n        innerRadius={innerRadius}\n        outerRadius={outerRadius}\n        startAngle={0}\n      >\n        {({ path }) => (\n          <motion.path\n            animate={{\n              scale: animate ? getScale() : 1,\n              opacity: isFaded ? 0.3 : 1,\n            }}\n            d={path(null) || \"\"}\n            fill={ringCssVars.ringBackground}\n            initial={animate ? { scale: 0 } : { scale: 1 }}\n            key={`bg-${animationKey}`}\n            style={{ transformOrigin: \"center\" }}\n            transition={{\n              scale: {\n                type: \"spring\",\n                stiffness: 400,\n                damping: 25,\n                delay: shouldDelay ? ringExpandDelay : 0,\n              },\n              opacity: { duration: 0.15 },\n            }}\n          />\n        )}\n      </Arc>\n\n      {/* Animated Progress arc */}\n      {animate ? (\n        <AnimatedProgressArc\n          animationKey={animationKey}\n          color={color}\n          index={index}\n          innerRadius={innerRadius}\n          isFaded={isFaded}\n          isHovered={isHovered}\n          isPushedOut={isPushedOut}\n          lineCap={lineCap}\n          outerRadius={outerRadius}\n          progress={progress}\n          showGlow={showGlow}\n        />\n      ) : (\n        <motion.path\n          animate={{\n            opacity: isFaded ? 0.4 : 1,\n            scale: getScale(),\n          }}\n          d={generateArcPath(\n            innerRadius,\n            outerRadius,\n            -Math.PI / 2,\n            -Math.PI / 2 + 2 * Math.PI * progress,\n            lineCap === \"round\" ? (outerRadius - innerRadius) / 2 : 0\n          )}\n          fill={color}\n          style={{\n            transformOrigin: \"center\",\n            filter:\n              showGlow && isHovered ? `drop-shadow(0 0 12px ${color})` : \"none\",\n          }}\n          transition={{\n            opacity: { duration: 0.15 },\n            scale: { type: \"spring\", stiffness: 400, damping: 25 },\n          }}\n        />\n      )}\n    </g>\n  );\n}\n\nRing.displayName = \"Ring\";\n\nexport default Ring;\n",
      "type": "registry:component",
      "target": "components/charts/ring.tsx"
    },
    {
      "path": "src/charts/ring-center.tsx",
      "content": "\"use client\";\n\nimport NumberFlow from \"@number-flow/react\";\nimport type { ReactNode } from \"react\";\nimport { cn } from \"../lib/utils\";\nimport { useRing } from \"./ring-context\";\n\n// NumberFlow format - subset of Intl.NumberFormatOptions\ninterface NumberFlowFormat {\n  notation?: \"standard\" | \"compact\";\n  compactDisplay?: \"short\" | \"long\";\n  minimumFractionDigits?: number;\n  maximumFractionDigits?: number;\n  minimumIntegerDigits?: number;\n  minimumSignificantDigits?: number;\n  maximumSignificantDigits?: number;\n  style?: \"decimal\" | \"percent\" | \"currency\";\n  currency?: string;\n  currencyDisplay?: \"symbol\" | \"narrowSymbol\" | \"code\" | \"name\";\n  unit?: string;\n  unitDisplay?: \"short\" | \"long\" | \"narrow\";\n}\n\nexport interface RingCenterProps {\n  /** Label shown below the value. Default: \"Total\" when not hovering */\n  defaultLabel?: string;\n  /** Format options for NumberFlow. Default: standard notation */\n  formatOptions?: NumberFlowFormat;\n  /** Custom render function for complete control over center content */\n  children?: (props: {\n    value: number;\n    label: string;\n    isHovered: boolean;\n    data: { label: string; value: number; maxValue: number; color?: string };\n  }) => ReactNode;\n  /** Additional class name for the container */\n  className?: string;\n  /** Class name for the value text. Default: \"text-2xl font-bold\" */\n  valueClassName?: string;\n  /** Class name for the label text. Default: \"text-xs\" */\n  labelClassName?: string;\n  /** Prefix to show before the number (e.g., \"$\") */\n  prefix?: string;\n  /** Suffix to show after the number (e.g., \"%\") */\n  suffix?: string;\n}\n\n// Default format options\nconst defaultFormatOptions: NumberFlowFormat = {\n  notation: \"standard\",\n  maximumFractionDigits: 0,\n};\n\n/**\n * RingCenter displays content in the center of the ring chart.\n *\n * This component renders as pure HTML (not inside SVG foreignObject) to avoid\n * Safari's WebKit bug #23113 where HTML content with CSS transforms/opacity\n * inside foreignObject renders at incorrect positions.\n *\n * The parent RingChart uses CSS Grid stacking to overlay this HTML content\n * on top of the SVG rings.\n */\nexport function RingCenter({\n  defaultLabel = \"Total\",\n  formatOptions = defaultFormatOptions,\n  children,\n  className = \"\",\n  valueClassName = \"text-2xl font-bold\",\n  labelClassName = \"text-xs\",\n  prefix,\n  suffix,\n}: RingCenterProps) {\n  const { data, hoveredIndex, totalValue, baseInnerRadius } = useRing();\n\n  const hoveredData = hoveredIndex !== null ? data[hoveredIndex] : null;\n  const displayValue = hoveredData ? hoveredData.value : totalValue;\n  const displayLabel = hoveredData ? hoveredData.label : defaultLabel;\n  const isHovered = hoveredIndex !== null;\n\n  // Calculate center area size based on scaled baseInnerRadius\n  // Leave some padding so text doesn't touch the inner ring\n  const centerSize = baseInnerRadius * 2 - 16;\n\n  // If custom render function is provided, use it\n  if (children && hoveredData) {\n    return (\n      <div\n        className={cn(\"flex items-center justify-center\", className)}\n        style={{ width: centerSize, height: centerSize }}\n      >\n        {children({\n          value: displayValue,\n          label: displayLabel,\n          isHovered,\n          data: hoveredData,\n        })}\n      </div>\n    );\n  }\n\n  // Default center content with NumberFlow animations\n  // Now renders as pure HTML, avoiding Safari's foreignObject bugs\n  return (\n    <div\n      className={cn(\n        \"flex flex-col items-center justify-center text-center\",\n        className\n      )}\n      style={{ width: centerSize, height: centerSize }}\n    >\n      <span className={cn(\"text-foreground tabular-nums\", valueClassName)}>\n        <NumberFlow\n          format={formatOptions}\n          prefix={prefix}\n          suffix={suffix}\n          value={displayValue}\n          willChange\n        />\n      </span>\n      <span className={cn(\"mt-0.5 text-chart-label\", labelClassName)}>\n        {displayLabel}\n      </span>\n    </div>\n  );\n}\n\nRingCenter.displayName = \"RingCenter\";\n\nexport default RingCenter;\n",
      "type": "registry:component",
      "target": "components/charts/ring-center.tsx"
    }
  ]
}
