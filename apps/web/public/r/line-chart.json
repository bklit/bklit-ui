{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "line-chart",
  "type": "registry:component",
  "title": "Line Chart",
  "description": "A composable line chart with multiple series support",
  "dependencies": [
    "@visx/curve@4.0.1-alpha.0",
    "@visx/shape@4.0.1-alpha.0",
    "motion"
  ],
  "registryDependencies": [
    "https://ui.bklit.com/r/chart-context.json",
    "https://ui.bklit.com/r/grid.json",
    "https://ui.bklit.com/r/x-axis.json",
    "https://ui.bklit.com/r/chart-tooltip.json",
    "https://ui.bklit.com/r/utils.json"
  ],
  "files": [
    {
      "path": "src/charts/line-chart.tsx",
      "content": "\"use client\";\n\nimport { ParentSize } from \"@visx/responsive\";\nimport { scaleLinear, scaleTime } from \"@visx/scale\";\nimport { bisector } from \"d3-array\";\nimport {\n  Children,\n  isValidElement,\n  type ReactElement,\n  type ReactNode,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport { cn } from \"../lib/utils\";\nimport { ChartProvider, type LineConfig, type Margin } from \"./chart-context\";\nimport { Line, type LineProps } from \"./line\";\nimport { useChartInteraction } from \"./use-chart-interaction\";\n\n// Check if a component should render after the mouse overlay (markers need to be on top for interaction)\nfunction isPostOverlayComponent(child: ReactElement): boolean {\n  const childType = child.type as {\n    displayName?: string;\n    name?: string;\n    __isChartMarkers?: boolean;\n  };\n\n  // Check for static marker property (more reliable than displayName)\n  if (childType.__isChartMarkers) {\n    return true;\n  }\n\n  // Fallback to displayName check\n  const componentName =\n    typeof child.type === \"function\"\n      ? childType.displayName || childType.name || \"\"\n      : \"\";\n\n  return componentName === \"ChartMarkers\" || componentName === \"MarkerGroup\";\n}\n\nexport interface LineChartProps {\n  /** Data array - each item should have a date field and numeric values */\n  data: Record<string, unknown>[];\n  /** Key in data for the x-axis (date). Default: \"date\" */\n  xDataKey?: string;\n  /** Chart margins */\n  margin?: Partial<Margin>;\n  /** Animation duration in milliseconds. Default: 1100 */\n  animationDuration?: number;\n  /** Aspect ratio as \"width / height\". Default: \"2 / 1\" */\n  aspectRatio?: string;\n  /** Additional class name for the container */\n  className?: string;\n  /** Child components (Line, Grid, ChartTooltip, etc.) */\n  children: ReactNode;\n}\n\nconst DEFAULT_MARGIN: Margin = { top: 40, right: 40, bottom: 40, left: 40 };\n\n// Extract line configs from children synchronously to avoid render timing issues\nfunction extractLineConfigs(children: ReactNode): LineConfig[] {\n  const configs: LineConfig[] = [];\n\n  Children.forEach(children, (child) => {\n    if (!isValidElement(child)) {\n      return;\n    }\n\n    // Check if it's a Line component by displayName, function reference, or props structure\n    const childType = child.type as {\n      displayName?: string;\n      name?: string;\n    };\n    const componentName =\n      typeof child.type === \"function\"\n        ? childType.displayName || childType.name || \"\"\n        : \"\";\n\n    // Check by displayName, or by props having dataKey (duck typing)\n    const props = child.props as LineProps | undefined;\n    const isLineComponent =\n      componentName === \"Line\" ||\n      child.type === Line ||\n      (props && typeof props.dataKey === \"string\" && props.dataKey.length > 0);\n\n    if (isLineComponent && props?.dataKey) {\n      configs.push({\n        dataKey: props.dataKey,\n        stroke: props.stroke || \"var(--chart-line-primary)\",\n        strokeWidth: props.strokeWidth || 2.5,\n      });\n    }\n  });\n\n  return configs;\n}\n\ninterface ChartInnerProps {\n  width: number;\n  height: number;\n  data: Record<string, unknown>[];\n  xDataKey: string;\n  margin: Margin;\n  animationDuration: number;\n  children: ReactNode;\n  containerRef: React.RefObject<HTMLDivElement | null>;\n}\n\nfunction ChartInner({\n  width,\n  height,\n  data,\n  xDataKey,\n  margin,\n  animationDuration,\n  children,\n  containerRef,\n}: ChartInnerProps) {\n  const [isLoaded, setIsLoaded] = useState(false);\n\n  // Extract line configs synchronously from children\n  const lines = useMemo(() => extractLineConfigs(children), [children]);\n\n  const innerWidth = width - margin.left - margin.right;\n  const innerHeight = height - margin.top - margin.bottom;\n\n  // X accessor function\n  const xAccessor = useCallback(\n    (d: Record<string, unknown>): Date => {\n      const value = d[xDataKey];\n      return value instanceof Date ? value : new Date(value as string | number);\n    },\n    [xDataKey]\n  );\n\n  // Create bisector for finding nearest data point\n  const bisectDate = useMemo(\n    () => bisector<Record<string, unknown>, Date>((d) => xAccessor(d)).left,\n    [xAccessor]\n  );\n\n  // X scale (time) - use exact data domain for tight fit\n  const xScale = useMemo(() => {\n    const dates = data.map((d) => xAccessor(d));\n    const minTime = Math.min(...dates.map((d) => d.getTime()));\n    const maxTime = Math.max(...dates.map((d) => d.getTime()));\n\n    return scaleTime({\n      range: [0, innerWidth],\n      domain: [minTime, maxTime],\n    });\n  }, [innerWidth, data, xAccessor]);\n\n  // Calculate column width (spacing between data points)\n  const columnWidth = useMemo(() => {\n    if (data.length < 2) {\n      return 0;\n    }\n    return innerWidth / (data.length - 1);\n  }, [innerWidth, data.length]);\n\n  // Y scale - computed from extracted line configs (available immediately)\n  const yScale = useMemo(() => {\n    let maxValue = 0;\n    for (const line of lines) {\n      for (const d of data) {\n        const value = d[line.dataKey];\n        if (typeof value === \"number\" && value > maxValue) {\n          maxValue = value;\n        }\n      }\n    }\n\n    if (maxValue === 0) {\n      maxValue = 100;\n    }\n\n    return scaleLinear({\n      range: [innerHeight, 0],\n      domain: [0, maxValue * 1.1],\n      nice: true,\n    });\n  }, [innerHeight, data, lines]);\n\n  // Pre-compute date labels for ticker animation\n  const dateLabels = useMemo(\n    () =>\n      data.map((d) =>\n        xAccessor(d).toLocaleDateString(\"en-US\", {\n          month: \"short\",\n          day: \"numeric\",\n        })\n      ),\n    [data, xAccessor]\n  );\n\n  // Animation timing\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setIsLoaded(true);\n    }, animationDuration);\n    return () => clearTimeout(timer);\n  }, [animationDuration]);\n\n  const canInteract = isLoaded;\n\n  const {\n    tooltipData,\n    setTooltipData,\n    selection,\n    clearSelection,\n    interactionHandlers,\n    interactionStyle,\n  } = useChartInteraction({\n    xScale,\n    yScale,\n    data,\n    lines,\n    margin,\n    xAccessor,\n    bisectDate,\n    canInteract,\n  });\n\n  // Early return if dimensions not ready\n  if (width < 10 || height < 10) {\n    return null;\n  }\n\n  // Separate children into pre-overlay (Grid, Line) and post-overlay (ChartMarkers)\n  const preOverlayChildren: ReactElement[] = [];\n  const postOverlayChildren: ReactElement[] = [];\n\n  Children.forEach(children, (child) => {\n    if (!isValidElement(child)) {\n      return;\n    }\n\n    if (isPostOverlayComponent(child)) {\n      postOverlayChildren.push(child);\n    } else {\n      preOverlayChildren.push(child);\n    }\n  });\n\n  const contextValue = {\n    data,\n    xScale,\n    yScale,\n    width,\n    height,\n    innerWidth,\n    innerHeight,\n    margin,\n    columnWidth,\n    tooltipData,\n    setTooltipData,\n    containerRef,\n    lines,\n    isLoaded,\n    animationDuration,\n    xAccessor,\n    dateLabels,\n    selection,\n    clearSelection,\n  };\n\n  return (\n    <ChartProvider value={contextValue}>\n      <svg aria-hidden=\"true\" height={height} width={width}>\n        <defs>\n          <clipPath id=\"chart-grow-clip\">\n            <rect\n              height={innerHeight + 20}\n              style={{\n                transition: isLoaded\n                  ? \"none\"\n                  : `width ${animationDuration}ms cubic-bezier(0.85, 0, 0.15, 1)`,\n              }}\n              width={isLoaded ? innerWidth : 0}\n              x={0}\n              y={0}\n            />\n          </clipPath>\n        </defs>\n\n        <rect fill=\"transparent\" height={height} width={width} x={0} y={0} />\n\n        <g\n          {...interactionHandlers}\n          style={interactionStyle}\n          transform={`translate(${margin.left},${margin.top})`}\n        >\n          <rect\n            fill=\"transparent\"\n            height={innerHeight}\n            width={innerWidth}\n            x={0}\n            y={0}\n          />\n\n          {preOverlayChildren}\n          {postOverlayChildren}\n        </g>\n      </svg>\n    </ChartProvider>\n  );\n}\n\nexport function LineChart({\n  data,\n  xDataKey = \"date\",\n  margin: marginProp,\n  animationDuration = 1100,\n  aspectRatio = \"2 / 1\",\n  className = \"\",\n  children,\n}: LineChartProps) {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const margin = { ...DEFAULT_MARGIN, ...marginProp };\n\n  return (\n    <div\n      className={cn(\"relative w-full\", className)}\n      ref={containerRef}\n      style={{ aspectRatio, touchAction: \"none\" }}\n    >\n      <ParentSize debounceTime={10}>\n        {({ width, height }) => (\n          <ChartInner\n            animationDuration={animationDuration}\n            containerRef={containerRef}\n            data={data}\n            height={height}\n            margin={margin}\n            width={width}\n            xDataKey={xDataKey}\n          >\n            {children}\n          </ChartInner>\n        )}\n      </ParentSize>\n    </div>\n  );\n}\n\n// Re-export Line for convenience\nexport { Line, type LineProps } from \"./line\";\n\nexport default LineChart;\n",
      "type": "registry:component",
      "target": "components/charts/line-chart.tsx"
    },
    {
      "path": "src/charts/line.tsx",
      "content": "\"use client\";\n\nimport { curveNatural } from \"@visx/curve\";\nimport { LinePath } from \"@visx/shape\";\n\n// CurveFactory type - simplified version compatible with visx\n// biome-ignore lint/suspicious/noExplicitAny: d3 curve factory type\ntype CurveFactory = any;\n\nimport { motion, useMotionTemplate, useSpring } from \"motion/react\";\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport { chartCssVars, useChart } from \"./chart-context\";\n\nexport interface LineProps {\n  /** Key in data to use for y values */\n  dataKey: string;\n  /** Stroke color. Default: var(--chart-line-primary) */\n  stroke?: string;\n  /** Stroke width. Default: 2.5 */\n  strokeWidth?: number;\n  /** Curve function. Default: curveNatural */\n  curve?: CurveFactory;\n  /** Whether to animate the line. Default: true */\n  animate?: boolean;\n  /** Whether to fade edges with gradient. Default: true */\n  fadeEdges?: boolean;\n  /** Whether to show highlight segment on hover. Default: true */\n  showHighlight?: boolean;\n}\n\nexport function Line({\n  dataKey,\n  stroke = chartCssVars.linePrimary,\n  strokeWidth = 2.5,\n  curve = curveNatural,\n  animate = true,\n  fadeEdges = true,\n  showHighlight = true,\n}: LineProps) {\n  const {\n    data,\n    xScale,\n    yScale,\n    innerHeight,\n    innerWidth,\n    tooltipData,\n    selection,\n    isLoaded,\n    animationDuration,\n    xAccessor,\n  } = useChart();\n\n  const pathRef = useRef<SVGPathElement>(null);\n  const [pathLength, setPathLength] = useState(0);\n  const [clipWidth, setClipWidth] = useState(0);\n\n  // Unique gradient ID for this line\n  const gradientId = useMemo(\n    () => `line-gradient-${dataKey}-${Math.random().toString(36).slice(2, 9)}`,\n    [dataKey]\n  );\n\n  // Measure path length and trigger animation\n  useEffect(() => {\n    if (pathRef.current && animate) {\n      const len = pathRef.current.getTotalLength();\n      if (len > 0) {\n        setPathLength(len);\n        if (!isLoaded) {\n          requestAnimationFrame(() => {\n            setClipWidth(innerWidth);\n          });\n        }\n      }\n    }\n  }, [animate, innerWidth, isLoaded]);\n\n  // Binary search to find path length at a given X coordinate\n  const findLengthAtX = useCallback(\n    (targetX: number): number => {\n      const path = pathRef.current;\n      if (!path || pathLength === 0) {\n        return 0;\n      }\n      let low = 0;\n      let high = pathLength;\n      const tolerance = 0.5;\n\n      while (high - low > tolerance) {\n        const mid = (low + high) / 2;\n        const point = path.getPointAtLength(mid);\n        if (point.x < targetX) {\n          low = mid;\n        } else {\n          high = mid;\n        }\n      }\n      return (low + high) / 2;\n    },\n    [pathLength]\n  );\n\n  // Calculate segment bounds for highlight from either selection or hover\n  const segmentBounds = useMemo(() => {\n    if (!pathRef.current || pathLength === 0) {\n      return { startLength: 0, segmentLength: 0, isActive: false };\n    }\n\n    // Selection takes priority over hover\n    if (selection?.active) {\n      const startLength = findLengthAtX(selection.startX);\n      const endLength = findLengthAtX(selection.endX);\n      return {\n        startLength,\n        segmentLength: endLength - startLength,\n        isActive: true,\n      };\n    }\n\n    if (!tooltipData) {\n      return { startLength: 0, segmentLength: 0, isActive: false };\n    }\n\n    const idx = tooltipData.index;\n    const startIdx = Math.max(0, idx - 1);\n    const endIdx = Math.min(data.length - 1, idx + 1);\n\n    const startPoint = data[startIdx];\n    const endPoint = data[endIdx];\n    if (!(startPoint && endPoint)) {\n      return { startLength: 0, segmentLength: 0, isActive: false };\n    }\n\n    const startX = xScale(xAccessor(startPoint)) ?? 0;\n    const endX = xScale(xAccessor(endPoint)) ?? 0;\n\n    const startLength = findLengthAtX(startX);\n    const endLength = findLengthAtX(endX);\n\n    return {\n      startLength,\n      segmentLength: endLength - startLength,\n      isActive: true,\n    };\n  }, [\n    tooltipData,\n    selection,\n    data,\n    xScale,\n    pathLength,\n    xAccessor,\n    findLengthAtX,\n  ]);\n\n  // Springs for smooth highlight animation (both offset AND segment length)\n  const springConfig = { stiffness: 180, damping: 28 };\n  const offsetSpring = useSpring(0, springConfig);\n  const segmentLengthSpring = useSpring(0, springConfig);\n\n  // Update springs when segment bounds change\n  useEffect(() => {\n    offsetSpring.set(-segmentBounds.startLength);\n    segmentLengthSpring.set(segmentBounds.segmentLength);\n  }, [\n    segmentBounds.startLength,\n    segmentBounds.segmentLength,\n    offsetSpring,\n    segmentLengthSpring,\n  ]);\n\n  // Create animated strokeDasharray using motion template\n  const animatedDasharray = useMotionTemplate`${segmentLengthSpring} ${pathLength}`;\n\n  // Get y value for a data point\n  const getY = useCallback(\n    (d: Record<string, unknown>) => {\n      const value = d[dataKey];\n      return typeof value === \"number\" ? (yScale(value) ?? 0) : 0;\n    },\n    [dataKey, yScale]\n  );\n\n  const isHovering = tooltipData !== null || selection?.active === true;\n  const easing = \"cubic-bezier(0.85, 0, 0.15, 1)\";\n\n  return (\n    <>\n      {/* Gradient definition for fading edges */}\n      {fadeEdges && (\n        <defs>\n          <linearGradient id={gradientId} x1=\"0%\" x2=\"100%\" y1=\"0%\" y2=\"0%\">\n            <stop offset=\"0%\" style={{ stopColor: stroke, stopOpacity: 0 }} />\n            <stop offset=\"15%\" style={{ stopColor: stroke, stopOpacity: 1 }} />\n            <stop offset=\"85%\" style={{ stopColor: stroke, stopOpacity: 1 }} />\n            <stop offset=\"100%\" style={{ stopColor: stroke, stopOpacity: 0 }} />\n          </linearGradient>\n        </defs>\n      )}\n\n      {/* Clip path for grow animation - unique per line */}\n      {animate && (\n        <defs>\n          <clipPath id={`grow-clip-${dataKey}`}>\n            <rect\n              height={innerHeight + 20}\n              style={{\n                transition:\n                  !isLoaded && clipWidth > 0\n                    ? `width ${animationDuration}ms ${easing}`\n                    : \"none\",\n              }}\n              width={isLoaded ? innerWidth : clipWidth}\n              x={0}\n              y={0}\n            />\n          </clipPath>\n        </defs>\n      )}\n\n      {/* Main line with clip path */}\n      <g clipPath={animate ? `url(#grow-clip-${dataKey})` : undefined}>\n        <motion.g\n          animate={{ opacity: isHovering && showHighlight ? 0.3 : 1 }}\n          initial={{ opacity: 1 }}\n          transition={{ duration: 0.4, ease: \"easeInOut\" }}\n        >\n          <LinePath\n            curve={curve}\n            data={data}\n            innerRef={pathRef}\n            stroke={fadeEdges ? `url(#${gradientId})` : stroke}\n            strokeLinecap=\"round\"\n            strokeWidth={strokeWidth}\n            x={(d) => xScale(xAccessor(d)) ?? 0}\n            y={getY}\n          />\n        </motion.g>\n      </g>\n\n      {/* Highlight segment on hover */}\n      {showHighlight && isHovering && isLoaded && pathRef.current && (\n        <motion.path\n          animate={{ opacity: 1 }}\n          d={pathRef.current.getAttribute(\"d\") || \"\"}\n          exit={{ opacity: 0 }}\n          fill=\"none\"\n          initial={{ opacity: 0 }}\n          stroke={stroke}\n          strokeLinecap=\"round\"\n          strokeWidth={strokeWidth}\n          style={{\n            strokeDasharray: animatedDasharray,\n            strokeDashoffset: offsetSpring,\n          }}\n          transition={{ duration: 0.4, ease: \"easeInOut\" }}\n        />\n      )}\n    </>\n  );\n}\n\nLine.displayName = \"Line\";\n\nexport default Line;\n",
      "type": "registry:component",
      "target": "components/charts/line.tsx"
    }
  ]
}