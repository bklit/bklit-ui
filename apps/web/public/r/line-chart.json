{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "line-chart",
  "type": "registry:component",
  "title": "Line Chart",
  "description": "A composable line chart with multiple series support",
  "dependencies": [
    "@visx/curve",
    "@visx/shape",
    "motion"
  ],
  "registryDependencies": [
    "https://ui.bklit.com/r/chart-context.json",
    "https://ui.bklit.com/r/grid.json",
    "https://ui.bklit.com/r/x-axis.json",
    "https://ui.bklit.com/r/chart-tooltip.json",
    "https://ui.bklit.com/r/utils.json"
  ],
  "files": [
    {
      "path": "src/charts/line-chart.tsx",
      "content": "\"use client\";\n\nimport { localPoint } from \"@visx/event\";\nimport { ParentSize } from \"@visx/responsive\";\nimport { scaleLinear, scaleTime } from \"@visx/scale\";\nimport { bisector } from \"d3-array\";\nimport {\n  Children,\n  isValidElement,\n  type ReactElement,\n  type ReactNode,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport { cn } from \"../lib/utils\";\nimport {\n  ChartProvider,\n  type LineConfig,\n  type Margin,\n  type TooltipData,\n} from \"./chart-context\";\nimport { Line, type LineProps } from \"./line\";\n\n// Check if a component should render after the mouse overlay (markers need to be on top for interaction)\nfunction isPostOverlayComponent(child: ReactElement): boolean {\n  const childType = child.type as {\n    displayName?: string;\n    name?: string;\n    __isChartMarkers?: boolean;\n  };\n\n  // Check for static marker property (more reliable than displayName)\n  if (childType.__isChartMarkers) {\n    return true;\n  }\n\n  // Fallback to displayName check\n  const componentName =\n    typeof child.type === \"function\"\n      ? childType.displayName || childType.name || \"\"\n      : \"\";\n\n  return componentName === \"ChartMarkers\" || componentName === \"MarkerGroup\";\n}\n\nexport interface LineChartProps {\n  /** Data array - each item should have a date field and numeric values */\n  data: Record<string, unknown>[];\n  /** Key in data for the x-axis (date). Default: \"date\" */\n  xDataKey?: string;\n  /** Chart margins */\n  margin?: Partial<Margin>;\n  /** Animation duration in milliseconds. Default: 1100 */\n  animationDuration?: number;\n  /** Aspect ratio as \"width / height\". Default: \"2 / 1\" */\n  aspectRatio?: string;\n  /** Additional class name for the container */\n  className?: string;\n  /** Child components (Line, Grid, ChartTooltip, etc.) */\n  children: ReactNode;\n}\n\nconst DEFAULT_MARGIN: Margin = { top: 40, right: 40, bottom: 40, left: 40 };\n\n// Extract line configs from children synchronously to avoid render timing issues\nfunction extractLineConfigs(children: ReactNode): LineConfig[] {\n  const configs: LineConfig[] = [];\n\n  Children.forEach(children, (child) => {\n    if (!isValidElement(child)) {\n      return;\n    }\n\n    // Check if it's a Line component by displayName, function reference, or props structure\n    const childType = child.type as {\n      displayName?: string;\n      name?: string;\n    };\n    const componentName =\n      typeof child.type === \"function\"\n        ? childType.displayName || childType.name || \"\"\n        : \"\";\n\n    // Check by displayName, or by props having dataKey (duck typing)\n    const props = child.props as LineProps | undefined;\n    const isLineComponent =\n      componentName === \"Line\" ||\n      child.type === Line ||\n      (props && typeof props.dataKey === \"string\" && props.dataKey.length > 0);\n\n    if (isLineComponent && props?.dataKey) {\n      configs.push({\n        dataKey: props.dataKey,\n        stroke: props.stroke || \"var(--chart-line-primary)\",\n        strokeWidth: props.strokeWidth || 2.5,\n      });\n    }\n  });\n\n  return configs;\n}\n\ninterface ChartInnerProps {\n  width: number;\n  height: number;\n  data: Record<string, unknown>[];\n  xDataKey: string;\n  margin: Margin;\n  animationDuration: number;\n  children: ReactNode;\n  containerRef: React.RefObject<HTMLDivElement | null>;\n}\n\nfunction ChartInner({\n  width,\n  height,\n  data,\n  xDataKey,\n  margin,\n  animationDuration,\n  children,\n  containerRef,\n}: ChartInnerProps) {\n  const [tooltipData, setTooltipData] = useState<TooltipData | null>(null);\n  const [isLoaded, setIsLoaded] = useState(false);\n\n  // Extract line configs synchronously from children\n  const lines = useMemo(() => extractLineConfigs(children), [children]);\n\n  const innerWidth = width - margin.left - margin.right;\n  const innerHeight = height - margin.top - margin.bottom;\n\n  // X accessor function\n  const xAccessor = useCallback(\n    (d: Record<string, unknown>): Date => {\n      const value = d[xDataKey];\n      return value instanceof Date ? value : new Date(value as string | number);\n    },\n    [xDataKey]\n  );\n\n  // Create bisector for finding nearest data point\n  const bisectDate = useMemo(\n    () => bisector<Record<string, unknown>, Date>((d) => xAccessor(d)).left,\n    [xAccessor]\n  );\n\n  // X scale (time) - use exact data domain for tight fit\n  const xScale = useMemo(() => {\n    const dates = data.map((d) => xAccessor(d));\n    const minTime = Math.min(...dates.map((d) => d.getTime()));\n    const maxTime = Math.max(...dates.map((d) => d.getTime()));\n\n    return scaleTime({\n      range: [0, innerWidth],\n      domain: [minTime, maxTime],\n    });\n  }, [innerWidth, data, xAccessor]);\n\n  // Calculate column width (spacing between data points)\n  const columnWidth = useMemo(() => {\n    if (data.length < 2) {\n      return 0;\n    }\n    return innerWidth / (data.length - 1);\n  }, [innerWidth, data.length]);\n\n  // Y scale - computed from extracted line configs (available immediately)\n  const yScale = useMemo(() => {\n    // Find max value across all line dataKeys\n    let maxValue = 0;\n    for (const line of lines) {\n      for (const d of data) {\n        const value = d[line.dataKey];\n        if (typeof value === \"number\" && value > maxValue) {\n          maxValue = value;\n        }\n      }\n    }\n\n    // Ensure we have a valid domain even if no data\n    if (maxValue === 0) {\n      maxValue = 100;\n    }\n\n    return scaleLinear({\n      range: [innerHeight, 0],\n      domain: [0, maxValue * 1.1], // Add 10% padding\n      nice: true,\n    });\n  }, [innerHeight, data, lines]);\n\n  // Pre-compute date labels for ticker animation\n  const dateLabels = useMemo(\n    () =>\n      data.map((d) =>\n        xAccessor(d).toLocaleDateString(\"en-US\", {\n          month: \"short\",\n          day: \"numeric\",\n        })\n      ),\n    [data, xAccessor]\n  );\n\n  // Animation timing\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setIsLoaded(true);\n    }, animationDuration);\n    return () => clearTimeout(timer);\n  }, [animationDuration]);\n\n  // Mouse move handler - works on the parent <g> element\n  const handleMouseMove = useCallback(\n    (event: React.MouseEvent<SVGGElement>) => {\n      const point = localPoint(event);\n      if (!point) {\n        return;\n      }\n\n      // localPoint returns coordinates relative to the SVG root, so subtract margin\n      const x0 = xScale.invert(point.x - margin.left);\n      const index = bisectDate(data, x0, 1);\n      const d0 = data[index - 1];\n      const d1 = data[index];\n\n      if (!d0) {\n        return;\n      }\n\n      // Find closest point\n      let d = d0;\n      let finalIndex = index - 1;\n      if (d1) {\n        const d0Time = xAccessor(d0).getTime();\n        const d1Time = xAccessor(d1).getTime();\n        if (x0.getTime() - d0Time > d1Time - x0.getTime()) {\n          d = d1;\n          finalIndex = index;\n        }\n      }\n\n      // Calculate y positions for each line\n      const yPositions: Record<string, number> = {};\n      for (const line of lines) {\n        const value = d[line.dataKey];\n        if (typeof value === \"number\") {\n          yPositions[line.dataKey] = yScale(value) ?? 0;\n        }\n      }\n\n      setTooltipData({\n        point: d,\n        index: finalIndex,\n        x: xScale(xAccessor(d)) ?? 0,\n        yPositions,\n      });\n    },\n    [xScale, yScale, data, lines, margin.left, xAccessor, bisectDate]\n  );\n\n  const handleMouseLeave = useCallback(() => {\n    setTooltipData(null);\n  }, []);\n\n  // Early return if dimensions not ready\n  if (width < 10 || height < 10) {\n    return null;\n  }\n\n  const canInteract = isLoaded;\n\n  // Separate children into pre-overlay (Grid, Line) and post-overlay (ChartMarkers)\n  const preOverlayChildren: ReactElement[] = [];\n  const postOverlayChildren: ReactElement[] = [];\n\n  Children.forEach(children, (child) => {\n    if (!isValidElement(child)) {\n      return;\n    }\n\n    if (isPostOverlayComponent(child)) {\n      postOverlayChildren.push(child);\n    } else {\n      preOverlayChildren.push(child);\n    }\n  });\n\n  const contextValue = {\n    data,\n    xScale,\n    yScale,\n    width,\n    height,\n    innerWidth,\n    innerHeight,\n    margin,\n    columnWidth,\n    tooltipData,\n    setTooltipData,\n    containerRef,\n    lines,\n    isLoaded,\n    animationDuration,\n    xAccessor,\n    dateLabels,\n  };\n\n  return (\n    <ChartProvider value={contextValue}>\n      <svg aria-hidden=\"true\" height={height} width={width}>\n        <defs>\n          {/* Clip path for grow animation */}\n          <clipPath id=\"chart-grow-clip\">\n            <rect\n              height={innerHeight + 20}\n              style={{\n                transition: isLoaded\n                  ? \"none\"\n                  : `width ${animationDuration}ms cubic-bezier(0.85, 0, 0.15, 1)`,\n              }}\n              width={isLoaded ? innerWidth : 0}\n              x={0}\n              y={0}\n            />\n          </clipPath>\n        </defs>\n\n        <rect fill=\"transparent\" height={height} width={width} x={0} y={0} />\n\n        {/* biome-ignore lint/a11y/noStaticElementInteractions: Chart interaction area */}\n        <g\n          onMouseLeave={canInteract ? handleMouseLeave : undefined}\n          onMouseMove={canInteract ? handleMouseMove : undefined}\n          style={{ cursor: canInteract ? \"crosshair\" : \"default\" }}\n          transform={`translate(${margin.left},${margin.top})`}\n        >\n          {/* Background rect for mouse event detection - markers rendered after this will receive events on top */}\n          <rect\n            fill=\"transparent\"\n            height={innerHeight}\n            width={innerWidth}\n            x={0}\n            y={0}\n          />\n\n          {/* SVG children rendered before markers (Grid, Line, etc.) */}\n          {preOverlayChildren}\n\n          {/* Markers rendered last so they're on top for interaction */}\n          {postOverlayChildren}\n        </g>\n      </svg>\n    </ChartProvider>\n  );\n}\n\nexport function LineChart({\n  data,\n  xDataKey = \"date\",\n  margin: marginProp,\n  animationDuration = 1100,\n  aspectRatio = \"2 / 1\",\n  className = \"\",\n  children,\n}: LineChartProps) {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const margin = { ...DEFAULT_MARGIN, ...marginProp };\n\n  return (\n    <div\n      className={cn(\"relative w-full\", className)}\n      ref={containerRef}\n      style={{ aspectRatio }}\n    >\n      <ParentSize debounceTime={10}>\n        {({ width, height }) => (\n          <ChartInner\n            animationDuration={animationDuration}\n            containerRef={containerRef}\n            data={data}\n            height={height}\n            margin={margin}\n            width={width}\n            xDataKey={xDataKey}\n          >\n            {children}\n          </ChartInner>\n        )}\n      </ParentSize>\n    </div>\n  );\n}\n\n// Re-export Line for convenience\nexport { Line, type LineProps } from \"./line\";\n\nexport default LineChart;\n",
      "type": "registry:component",
      "target": "components/charts/line-chart.tsx"
    },
    {
      "path": "src/charts/line.tsx",
      "content": "\"use client\";\n\nimport { curveNatural } from \"@visx/curve\";\nimport { LinePath } from \"@visx/shape\";\n\n// CurveFactory type - simplified version compatible with visx\n// biome-ignore lint/suspicious/noExplicitAny: d3 curve factory type\ntype CurveFactory = any;\n\nimport { motion, useMotionTemplate, useSpring } from \"motion/react\";\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport { chartCssVars, useChart } from \"./chart-context\";\n\nexport interface LineProps {\n  /** Key in data to use for y values */\n  dataKey: string;\n  /** Stroke color. Default: var(--chart-line-primary) */\n  stroke?: string;\n  /** Stroke width. Default: 2.5 */\n  strokeWidth?: number;\n  /** Curve function. Default: curveNatural */\n  curve?: CurveFactory;\n  /** Whether to animate the line. Default: true */\n  animate?: boolean;\n  /** Whether to fade edges with gradient. Default: true */\n  fadeEdges?: boolean;\n  /** Whether to show highlight segment on hover. Default: true */\n  showHighlight?: boolean;\n}\n\nexport function Line({\n  dataKey,\n  stroke = chartCssVars.linePrimary,\n  strokeWidth = 2.5,\n  curve = curveNatural,\n  animate = true,\n  fadeEdges = true,\n  showHighlight = true,\n}: LineProps) {\n  const {\n    data,\n    xScale,\n    yScale,\n    innerHeight,\n    innerWidth,\n    tooltipData,\n    isLoaded,\n    animationDuration,\n    xAccessor,\n  } = useChart();\n\n  const pathRef = useRef<SVGPathElement>(null);\n  const [pathLength, setPathLength] = useState(0);\n  const [clipWidth, setClipWidth] = useState(0);\n\n  // Unique gradient ID for this line\n  const gradientId = useMemo(\n    () => `line-gradient-${dataKey}-${Math.random().toString(36).slice(2, 9)}`,\n    [dataKey]\n  );\n\n  // Measure path length and trigger animation\n  useEffect(() => {\n    if (pathRef.current && animate) {\n      const len = pathRef.current.getTotalLength();\n      if (len > 0) {\n        setPathLength(len);\n        if (!isLoaded) {\n          requestAnimationFrame(() => {\n            setClipWidth(innerWidth);\n          });\n        }\n      }\n    }\n  }, [animate, innerWidth, isLoaded]);\n\n  // Calculate segment bounds for highlight (returns numeric values for animation)\n  const segmentBounds = useMemo(() => {\n    if (!(tooltipData && pathRef.current) || pathLength === 0) {\n      return { startLength: 0, segmentLength: 0, isActive: false };\n    }\n\n    const idx = tooltipData.index;\n    const startIdx = Math.max(0, idx - 1);\n    const endIdx = Math.min(data.length - 1, idx + 1);\n\n    const path = pathRef.current;\n\n    // Binary search to find length at X\n    const findLengthAtX = (targetX: number): number => {\n      let low = 0;\n      let high = pathLength;\n      const tolerance = 0.5;\n\n      while (high - low > tolerance) {\n        const mid = (low + high) / 2;\n        const point = path.getPointAtLength(mid);\n        if (point.x < targetX) {\n          low = mid;\n        } else {\n          high = mid;\n        }\n      }\n      return (low + high) / 2;\n    };\n\n    const startPoint = data[startIdx];\n    const endPoint = data[endIdx];\n    if (!(startPoint && endPoint)) {\n      return { startLength: 0, segmentLength: 0, isActive: false };\n    }\n\n    const startX = xScale(xAccessor(startPoint)) ?? 0;\n    const endX = xScale(xAccessor(endPoint)) ?? 0;\n\n    const startLength = findLengthAtX(startX);\n    const endLength = findLengthAtX(endX);\n    const segmentLength = endLength - startLength;\n\n    return { startLength, segmentLength, isActive: true };\n  }, [tooltipData, data, xScale, pathLength, xAccessor]);\n\n  // Springs for smooth highlight animation (both offset AND segment length)\n  const springConfig = { stiffness: 180, damping: 28 };\n  const offsetSpring = useSpring(0, springConfig);\n  const segmentLengthSpring = useSpring(0, springConfig);\n\n  // Update springs when segment bounds change\n  useEffect(() => {\n    offsetSpring.set(-segmentBounds.startLength);\n    segmentLengthSpring.set(segmentBounds.segmentLength);\n  }, [\n    segmentBounds.startLength,\n    segmentBounds.segmentLength,\n    offsetSpring,\n    segmentLengthSpring,\n  ]);\n\n  // Create animated strokeDasharray using motion template\n  const animatedDasharray = useMotionTemplate`${segmentLengthSpring} ${pathLength}`;\n\n  // Get y value for a data point\n  const getY = useCallback(\n    (d: Record<string, unknown>) => {\n      const value = d[dataKey];\n      return typeof value === \"number\" ? (yScale(value) ?? 0) : 0;\n    },\n    [dataKey, yScale]\n  );\n\n  const isHovering = tooltipData !== null;\n  const easing = \"cubic-bezier(0.85, 0, 0.15, 1)\";\n\n  return (\n    <>\n      {/* Gradient definition for fading edges */}\n      {fadeEdges && (\n        <defs>\n          <linearGradient id={gradientId} x1=\"0%\" x2=\"100%\" y1=\"0%\" y2=\"0%\">\n            <stop offset=\"0%\" style={{ stopColor: stroke, stopOpacity: 0 }} />\n            <stop offset=\"15%\" style={{ stopColor: stroke, stopOpacity: 1 }} />\n            <stop offset=\"85%\" style={{ stopColor: stroke, stopOpacity: 1 }} />\n            <stop offset=\"100%\" style={{ stopColor: stroke, stopOpacity: 0 }} />\n          </linearGradient>\n        </defs>\n      )}\n\n      {/* Clip path for grow animation - unique per line */}\n      {animate && (\n        <defs>\n          <clipPath id={`grow-clip-${dataKey}`}>\n            <rect\n              height={innerHeight + 20}\n              style={{\n                transition:\n                  !isLoaded && clipWidth > 0\n                    ? `width ${animationDuration}ms ${easing}`\n                    : \"none\",\n              }}\n              width={isLoaded ? innerWidth : clipWidth}\n              x={0}\n              y={0}\n            />\n          </clipPath>\n        </defs>\n      )}\n\n      {/* Main line with clip path */}\n      <g clipPath={animate ? `url(#grow-clip-${dataKey})` : undefined}>\n        <motion.g\n          animate={{ opacity: isHovering && showHighlight ? 0.3 : 1 }}\n          initial={{ opacity: 1 }}\n          transition={{ duration: 0.4, ease: \"easeInOut\" }}\n        >\n          <LinePath\n            curve={curve}\n            data={data}\n            innerRef={pathRef}\n            stroke={fadeEdges ? `url(#${gradientId})` : stroke}\n            strokeLinecap=\"round\"\n            strokeWidth={strokeWidth}\n            x={(d) => xScale(xAccessor(d)) ?? 0}\n            y={getY}\n          />\n        </motion.g>\n      </g>\n\n      {/* Highlight segment on hover */}\n      {showHighlight && isHovering && isLoaded && pathRef.current && (\n        <motion.path\n          animate={{ opacity: 1 }}\n          d={pathRef.current.getAttribute(\"d\") || \"\"}\n          exit={{ opacity: 0 }}\n          fill=\"none\"\n          initial={{ opacity: 0 }}\n          stroke={stroke}\n          strokeLinecap=\"round\"\n          strokeWidth={strokeWidth}\n          style={{\n            strokeDasharray: animatedDasharray,\n            strokeDashoffset: offsetSpring,\n          }}\n          transition={{ duration: 0.4, ease: \"easeInOut\" }}\n        />\n      )}\n    </>\n  );\n}\n\nLine.displayName = \"Line\";\n\nexport default Line;\n",
      "type": "registry:component",
      "target": "components/charts/line.tsx"
    }
  ]
}